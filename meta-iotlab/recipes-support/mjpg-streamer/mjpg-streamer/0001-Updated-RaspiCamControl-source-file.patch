From 3a6f9ea535581400621c3cd547e961fe14784606 Mon Sep 17 00:00:00 2001
From: Florian Harr <harr.florian@gmx.de>
Date: Tue, 7 Feb 2017 15:42:52 -0500
Subject: [PATCH] Updated RaspiCamControl source file

---
 .../plugins/input_raspicam/RaspiCamControl.c       | 178 ++++++--
 .../plugins/input_raspicam/RaspiCamControl.h       |  10 +-
 .../plugins/input_raspicam/mmal/CMakeLists.txt     |  42 +-
 .../input_raspicam/mmal/core/CMakeLists.txt        |  11 +-
 .../plugins/input_raspicam/mmal/core/mmal_clock.c  | 315 +++++++------
 .../input_raspicam/mmal/core/mmal_clock_private.h  |  33 +-
 .../input_raspicam/mmal/core/mmal_component.c      |  61 ++-
 .../mmal/core/mmal_component_private.h             |   8 +
 .../plugins/input_raspicam/mmal/core/mmal_events.c |  64 ++-
 .../plugins/input_raspicam/mmal/core/mmal_format.c |   5 +-
 .../plugins/input_raspicam/mmal/core/mmal_port.c   |  38 +-
 .../input_raspicam/mmal/core/mmal_port_clock.c     | 490 +++++++++++++++------
 .../input_raspicam/mmal/core/mmal_port_private.h   | 114 +++--
 .../plugins/input_raspicam/mmal/core/mmal_queue.c  |  86 +++-
 .../plugins/input_raspicam/mmal/mmal.h             |   2 +-
 .../plugins/input_raspicam/mmal/mmal_buffer.h      |  16 +-
 .../plugins/input_raspicam/mmal/mmal_encodings.h   |  38 ++
 .../plugins/input_raspicam/mmal/mmal_events.h      |   9 -
 .../input_raspicam/mmal/mmal_parameters_camera.h   |   1 +
 .../input_raspicam/mmal/mmal_parameters_video.h    |  20 +
 .../plugins/input_raspicam/mmal/mmal_queue.h       |  11 +
 .../input_raspicam/mmal/util/CMakeLists.txt        |  15 +-
 .../input_raspicam/mmal/util/mmal_connection.c     |  57 ++-
 .../input_raspicam/mmal/util/mmal_connection.h     |   6 +
 .../mmal/util/mmal_default_components.h            |   5 +
 .../plugins/input_raspicam/mmal/util/mmal_graph.c  | 354 ++++++++++++---
 .../plugins/input_raspicam/mmal/util/mmal_graph.h  |  41 ++
 .../plugins/input_raspicam/mmal/util/mmal_il.c     | 229 +++++++++-
 .../plugins/input_raspicam/mmal/util/mmal_il.h     |  25 ++
 .../plugins/input_raspicam/mmal/util/mmal_list.c   |   3 +
 .../input_raspicam/mmal/util/mmal_param_convert.c  |   1 -
 .../plugins/input_raspicam/mmal/util/mmal_util.c   | 138 +++++-
 .../plugins/input_raspicam/mmal/util/mmal_util.h   |  20 +-
 .../input_raspicam/mmal/util/mmal_util_params.h    |   2 +-
 .../input_raspicam/mmal/util/mmal_util_rational.c  |   8 +
 .../input_raspicam/mmal/util/mmal_util_rational.h  |   9 +
 .../plugins/input_raspicam/mmal/vc/CMakeLists.txt  |  21 +-
 .../plugins/input_raspicam/mmal/vc/mmal_vc_api.c   | 101 +++--
 .../plugins/input_raspicam/mmal/vc/mmal_vc_api.h   |  20 +
 .../input_raspicam/mmal/vc/mmal_vc_client.c        |  22 +-
 .../input_raspicam/mmal/vc/mmal_vc_msgnames.c      |   1 +
 .../plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h  |  27 +-
 .../plugins/input_raspicam/mmal/vc/mmal_vc_shm.c   |   8 +-
 43 files changed, 2034 insertions(+), 631 deletions(-)

diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c b/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c
index 2d343f0..fe1bc8c 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c
@@ -434,7 +434,6 @@ int raspicamcontrol_cycle_test(MMAL_COMPONENT_T *camera)
    return 1;
 }
 
-
 /**
  * Function to take a string, a mapping, and return the int equivalent
  * @param str Incoming string to match
@@ -489,7 +488,7 @@ static MMAL_PARAM_EXPOSUREMODE_T exposure_mode_from_string(const char *str)
    if( i != -1)
       return (MMAL_PARAM_EXPOSUREMODE_T)i;
 
-   fprintf(stderr,"Unknown exposure mode: %s", str);
+   fprintf(stderr, "Unknown exposure mode: %s", str);
    return MMAL_PARAM_EXPOSUREMODE_AUTO;
 }
 
@@ -505,7 +504,7 @@ static MMAL_PARAM_AWBMODE_T awb_mode_from_string(const char *str)
    if( i != -1)
       return (MMAL_PARAM_AWBMODE_T)i;
 
-   fprintf(stderr,"Unknown awb mode: %s", str);
+   fprintf(stderr, "Unknown awb mode: %s", str);
    return MMAL_PARAM_AWBMODE_AUTO;
 }
 
@@ -521,7 +520,7 @@ MMAL_PARAM_IMAGEFX_T imagefx_mode_from_string(const char *str)
    if( i != -1)
      return (MMAL_PARAM_IMAGEFX_T)i;
 
-   fprintf(stderr,"Unknown image fx: %s", str);
+   fprintf(stderr, "Unknown image fx: %s", str);
    return MMAL_PARAM_IMAGEFX_NONE;
 }
 
@@ -537,11 +536,11 @@ static MMAL_PARAM_EXPOSUREMETERINGMODE_T metering_mode_from_string(const char *s
    if( i != -1)
       return (MMAL_PARAM_EXPOSUREMETERINGMODE_T)i;
 
-   fprintf(stderr,"Unknown metering mode: %s", str);
+   fprintf(stderr, "Unknown metering mode: %s", str);
    return MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE;
 }
 
- /**
+/**
  * Convert string to the MMAL parameter for DRC level
  * @param str Incoming string to match
  * @return MMAL parameter matching the string, or the AUTO option if no match found
@@ -553,7 +552,7 @@ static MMAL_PARAMETER_DRC_STRENGTH_T drc_mode_from_string(const char *str)
    if( i != -1)
       return (MMAL_PARAMETER_DRC_STRENGTH_T)i;
 
-   fprintf(stderr,"Unknown DRC level: %s", str);
+   fprintf(stderr, "Unknown DRC level: %s", str);
    return MMAL_PARAMETER_DRC_STRENGTH_OFF;
 }
 
@@ -569,17 +568,10 @@ static MMAL_STEREOSCOPIC_MODE_T stereo_mode_from_string(const char *str)
    if( i != -1)
       return (MMAL_STEREOSCOPIC_MODE_T)i;
 
-   fprintf(stderr,"Unknown metering mode: %s", str);
+   fprintf(stderr, "Unknown metering mode: %s", str);
    return MMAL_STEREOSCOPIC_MODE_NONE;
 }
 
-
-
-
-
-
-
-
 /**
  * Dump contents of camera parameter structure to stderr for debugging/verbose logging
  *
@@ -615,22 +607,22 @@ int mmal_status_to_int(MMAL_STATUS_T status)
    {
       switch (status)
       {
-      case MMAL_ENOMEM :   fprintf(stderr,"Out of memory"); break;
-      case MMAL_ENOSPC :   fprintf(stderr,"Out of resources (other than memory)"); break;
-      case MMAL_EINVAL:    fprintf(stderr,"Argument is invalid"); break;
-      case MMAL_ENOSYS :   fprintf(stderr,"Function not implemented"); break;
-      case MMAL_ENOENT :   fprintf(stderr,"No such file or directory"); break;
-      case MMAL_ENXIO :    fprintf(stderr,"No such device or address"); break;
-      case MMAL_EIO :      fprintf(stderr,"I/O error"); break;
-      case MMAL_ESPIPE :   fprintf(stderr,"Illegal seek"); break;
-      case MMAL_ECORRUPT : fprintf(stderr,"Data is corrupt \attention FIXME: not POSIX"); break;
-      case MMAL_ENOTREADY :fprintf(stderr,"Component is not ready \attention FIXME: not POSIX"); break;
-      case MMAL_ECONFIG :  fprintf(stderr,"Component is not configured \attention FIXME: not POSIX"); break;
-      case MMAL_EISCONN :  fprintf(stderr,"Port is already connected "); break;
-      case MMAL_ENOTCONN : fprintf(stderr,"Port is disconnected"); break;
-      case MMAL_EAGAIN :   fprintf(stderr,"Resource temporarily unavailable. Try again later"); break;
-      case MMAL_EFAULT :   fprintf(stderr,"Bad address"); break;
-      default :            fprintf(stderr,"Unknown status error"); break;
+      case MMAL_ENOMEM :   fprintf(stderr, "Out of memory"); break;
+      case MMAL_ENOSPC :   fprintf(stderr, "Out of resources (other than memory)"); break;
+      case MMAL_EINVAL:    fprintf(stderr, "Argument is invalid"); break;
+      case MMAL_ENOSYS :   fprintf(stderr, "Function not implemented"); break;
+      case MMAL_ENOENT :   fprintf(stderr, "No such file or directory"); break;
+      case MMAL_ENXIO :    fprintf(stderr, "No such device or address"); break;
+      case MMAL_EIO :      fprintf(stderr, "I/O error"); break;
+      case MMAL_ESPIPE :   fprintf(stderr, "Illegal seek"); break;
+      case MMAL_ECORRUPT : fprintf(stderr, "Data is corrupt \attention FIXME: not POSIX"); break;
+      case MMAL_ENOTREADY :fprintf(stderr, "Component is not ready \attention FIXME: not POSIX"); break;
+      case MMAL_ECONFIG :  fprintf(stderr, "Component is not configured \attention FIXME: not POSIX"); break;
+      case MMAL_EISCONN :  fprintf(stderr, "Port is already connected "); break;
+      case MMAL_ENOTCONN : fprintf(stderr, "Port is disconnected"); break;
+      case MMAL_EAGAIN :   fprintf(stderr, "Resource temporarily unavailable. Try again later"); break;
+      case MMAL_EFAULT :   fprintf(stderr, "Bad address"); break;
+      default :            fprintf(stderr, "Unknown status error"); break;
       }
 
       return 1;
@@ -739,6 +731,10 @@ int raspicamcontrol_set_all_parameters(MMAL_COMPONENT_T *camera, const RASPICAM_
    result += raspicamcontrol_set_shutter_speed(camera, params->shutter_speed);
    result += raspicamcontrol_set_DRC(camera, params->drc_level);
    result += raspicamcontrol_set_stats_pass(camera, params->stats_pass);
+   result += raspicamcontrol_set_annotate(camera, params->enable_annotate, params->annotate_string,
+                       params->annotate_text_size,
+                       params->annotate_text_colour,
+                       params->annotate_bg_colour);
 
    return result;
 }
@@ -763,7 +759,7 @@ int raspicamcontrol_set_saturation(MMAL_COMPONENT_T *camera, int saturation)
    }
    else
    {
-      fprintf(stderr,"Invalid saturation value");
+      fprintf(stderr, "Invalid saturation value");
       ret = 1;
    }
 
@@ -789,7 +785,7 @@ int raspicamcontrol_set_sharpness(MMAL_COMPONENT_T *camera, int sharpness)
    }
    else
    {
-      fprintf(stderr,"Invalid sharpness value");
+      fprintf(stderr, "Invalid sharpness value");
       ret = 1;
    }
 
@@ -816,7 +812,7 @@ int raspicamcontrol_set_contrast(MMAL_COMPONENT_T *camera, int contrast)
    }
    else
    {
-      fprintf(stderr,"Invalid contrast value");
+      fprintf(stderr, "Invalid contrast value");
       ret = 1;
    }
 
@@ -843,7 +839,7 @@ int raspicamcontrol_set_brightness(MMAL_COMPONENT_T *camera, int brightness)
    }
    else
    {
-      fprintf(stderr,"Invalid brightness value");
+      fprintf(stderr, "Invalid brightness value");
       ret = 1;
    }
 
@@ -1161,6 +1157,109 @@ int raspicamcontrol_set_stats_pass(MMAL_COMPONENT_T *camera, int stats_pass)
 }
 
 
+/**
+ * Set the annotate data
+ * @param camera Pointer to camera component
+ * @param Bitmask of required annotation data. 0 for off.
+ * @param If set, a pointer to text string to use instead of bitmask, max length 32 characters
+ *
+ * @return 0 if successful, non-zero if any parameters out of range
+ */
+int raspicamcontrol_set_annotate(MMAL_COMPONENT_T *camera, const int settings, const char *string,
+                const int text_size, const int text_colour, const int bg_colour)
+{
+   MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T annotate =
+      {{MMAL_PARAMETER_ANNOTATE, sizeof(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T)}};
+
+   if (settings)
+   {
+      time_t t = time(NULL);
+      struct tm tm = *localtime(&t);
+      char tmp[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3];
+      int process_datetime = 1;
+
+      annotate.enable = 1;
+
+      if (settings & (ANNOTATE_APP_TEXT | ANNOTATE_USER_TEXT))
+      {
+         if ((settings & (ANNOTATE_TIME_TEXT | ANNOTATE_DATE_TEXT)) && strchr(string,'%') != NULL)
+         {  //string contains strftime parameter?
+            strftime(annotate.text, MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3, string, &tm );
+            process_datetime = 0;
+         }else{
+            strncpy(annotate.text, string, MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3);
+         }
+         annotate.text[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3-1] = '\0';
+      }
+
+      if (process_datetime && (settings & ANNOTATE_TIME_TEXT))
+      {
+         if(strlen(annotate.text)){
+            strftime(tmp, 32, " %X", &tm );
+         }else{
+            strftime(tmp, 32, "%X", &tm );
+         }
+         strncat(annotate.text, tmp, MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3 - strlen(annotate.text) - 1);
+      }
+
+      if (process_datetime && (settings & ANNOTATE_DATE_TEXT))
+      {
+         if(strlen(annotate.text)){
+            strftime(tmp, 32, " %x", &tm );
+         }else{
+            strftime(tmp, 32, "%x", &tm );
+         }
+         strncat(annotate.text, tmp, MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3 - strlen(annotate.text) - 1);
+      }
+
+      if (settings & ANNOTATE_SHUTTER_SETTINGS)
+         annotate.show_shutter = MMAL_TRUE;
+
+      if (settings & ANNOTATE_GAIN_SETTINGS)
+         annotate.show_analog_gain = MMAL_TRUE;
+
+      if (settings & ANNOTATE_LENS_SETTINGS)
+         annotate.show_lens = MMAL_TRUE;
+
+      if (settings & ANNOTATE_CAF_SETTINGS)
+         annotate.show_caf = MMAL_TRUE;
+
+      if (settings & ANNOTATE_MOTION_SETTINGS)
+         annotate.show_motion = MMAL_TRUE;
+
+      if (settings & ANNOTATE_FRAME_NUMBER)
+         annotate.show_frame_num = MMAL_TRUE;
+
+      if (settings & ANNOTATE_BLACK_BACKGROUND)
+         annotate.enable_text_background = MMAL_TRUE;
+
+      annotate.text_size = text_size;
+
+      if (text_colour != -1)
+      {
+         annotate.custom_text_colour = MMAL_TRUE;
+         annotate.custom_text_Y = text_colour&0xff;
+         annotate.custom_text_U = (text_colour>>8)&0xff;
+         annotate.custom_text_V = (text_colour>>16)&0xff;
+      }
+      else
+         annotate.custom_text_colour = MMAL_FALSE;
+
+      if (bg_colour != -1)
+      {
+         annotate.custom_background_colour = MMAL_TRUE;
+         annotate.custom_background_Y = bg_colour&0xff;
+         annotate.custom_background_U = (bg_colour>>8)&0xff;
+         annotate.custom_background_V = (bg_colour>>16)&0xff;
+      }
+      else
+         annotate.custom_background_colour = MMAL_FALSE;
+    }
+    else
+       annotate.enable = 0;
+
+   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &annotate.hdr));
+}
 
 int raspicamcontrol_set_stereo_mode(MMAL_PORT_T *port, MMAL_PARAMETER_STEREOSCOPIC_MODE_T *stereo_mode)
 {
@@ -1217,12 +1316,11 @@ void raspicamcontrol_check_configuration(int min_gpu_mem)
    int supported = 0, detected = 0;
    raspicamcontrol_get_camera(&supported, &detected);
    if (!supported)
-      fprintf(stderr,"Camera is not enabled in this build. Try running \"sudo raspi-config\" and ensure that \"camera\" has been enabled\n");
+      fprintf(stderr, "Camera is not enabled in this build. Try running \"sudo raspi-config\" and ensure that \"camera\" has been enabled\n");
    else if (gpu_mem < min_gpu_mem)
-      fprintf(stderr,"Only %dM of gpu_mem is configured. Try running \"sudo raspi-config\" and ensure that \"memory_split\" has a value of %d or greater\n", gpu_mem, min_gpu_mem);
+      fprintf(stderr, "Only %dM of gpu_mem is configured. Try running \"sudo raspi-config\" and ensure that \"memory_split\" has a value of %d or greater\n", gpu_mem, min_gpu_mem);
    else if (!detected)
-      fprintf(stderr,"Camera is not detected. Please check carefully the camera module is installed correctly\n");
+      fprintf(stderr, "Camera is not detected. Please check carefully the camera module is installed correctly\n");
    else
-      fprintf(stderr,"Failed to run camera app. Please check for firmware updates\n");
+      fprintf(stderr, "Failed to run camera app. Please check for firmware updates\n");
 }
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.h b/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.h
index 33377ec..88d086e 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.h
@@ -105,20 +105,20 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 // There isn't actually a MMAL structure for the following, so make one
-typedef struct
+typedef struct mmal_param_colourfx_s
 {
    int enable;       /// Turn colourFX on or off
    int u,v;          /// U and V to use
 } MMAL_PARAM_COLOURFX_T;
 
-typedef struct
+typedef struct mmal_param_thumbnail_config_s
 {
    int enable;
    int width,height;
    int quality;
 } MMAL_PARAM_THUMBNAIL_CONFIG_T;
 
-typedef struct
+typedef struct param_float_rect_s
 {
    double x;
    double y;
@@ -127,7 +127,7 @@ typedef struct
 } PARAM_FLOAT_RECT_T;
 
 /// struct contain camera settings
-typedef struct
+typedef struct raspicam_camera_parameters_s
 {
    int sharpness;             /// -100 to 100
    int contrast;              /// -100 to 100
@@ -214,4 +214,4 @@ MMAL_PARAM_IMAGEFX_T raspicamcontrol_get_imageFX(MMAL_COMPONENT_T *camera);
 MMAL_PARAM_COLOURFX_T raspicamcontrol_get_colourFX(MMAL_COMPONENT_T *camera);
 
 
-#endif /* RASPICAMCONTROL_H_ */
+#endif /* RASPICAMCONTROL_H_ */
\ No newline at end of file
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/CMakeLists.txt
index ae5889d..37ae757 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/CMakeLists.txt
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/CMakeLists.txt
@@ -1,3 +1,7 @@
+# We support building both static and shared libraries
+if (NOT DEFINED LIBRARY_TYPE)
+set(LIBRARY_TYPE SHARED)
+endif (NOT DEFINED LIBRARY_TYPE)
 
 add_definitions(-Wall -Werror)
 
@@ -6,15 +10,37 @@ add_library(mmal SHARED util/mmal_util.c)
 add_subdirectory(core)
 add_subdirectory(util)
 add_subdirectory(vc)
-
-#add_subdirectory(test/lua)
-#add_subdirectory(test/standalone)
-
-if(BUILD_MMAL_APPS)
 add_subdirectory(components)
+add_subdirectory(openmaxil)
+add_subdirectory(client)
+
 target_link_libraries(mmal mmal_core mmal_util mmal_vc_client vcos mmal_components)
-else(BUILD_MMAL_APPS)
-target_link_libraries(mmal mmal_core mmal_util mmal_vc_client)
-endif(BUILD_MMAL_APPS)
 
 install(TARGETS mmal DESTINATION lib)
+install(FILES
+   mmal.h
+   mmal_buffer.h
+   mmal_clock.h
+   mmal_common.h
+   mmal_component.h
+   mmal_encodings.h
+   mmal_events.h
+   mmal_format.h
+   mmal_logging.h
+   mmal_metadata.h
+   mmal_parameters.h
+   mmal_parameters_audio.h
+   mmal_parameters_camera.h
+   mmal_parameters_clock.h
+   mmal_parameters_common.h
+   mmal_parameters_video.h
+   mmal_pool.h mmal_port.h
+   mmal_queue.h
+   mmal_types.h
+   DESTINATION include/interface/mmal
+)
+
+# Test apps
+if(BUILD_MMAL_APPS)
+add_subdirectory(test)
+endif(BUILD_MMAL_APPS)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/CMakeLists.txt
index b5bae4c..de0bcb2 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/CMakeLists.txt
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/CMakeLists.txt
@@ -1,4 +1,4 @@
-add_library (mmal_core SHARED
+add_library (mmal_core ${LIBRARY_TYPE}
    mmal_format.c
    mmal_port.c
    mmal_port_clock.c
@@ -14,3 +14,12 @@ add_library (mmal_core SHARED
 target_link_libraries (mmal_core vcos)
 
 install(TARGETS mmal_core DESTINATION lib)
+install(FILES
+   mmal_buffer_private.h
+   mmal_clock_private.h
+   mmal_component_private.h
+   mmal_core_private.h
+   mmal_port_private.h
+   mmal_events_private.h
+   DESTINATION include/interface/mmal/core
+)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock.c
index 6f6c64f..23f3043 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock.c
@@ -96,11 +96,10 @@ typedef struct MMAL_CLOCK_REQUEST_T
    MMAL_CLOCK_VOID_FP priv;  /**< client-supplied function pointer */
    MMAL_CLOCK_REQUEST_CB cb; /**< client-supplied callback to invoke */
    void *cb_data;            /**< client-supplied callback data */
-   int64_t offset;           /**< time offset requested by the client (microseconds) */
    int64_t media_time;       /**< media-time requested by the client (microseconds) */
-   int64_t media_time_adj;   /**< adjusted media-time at which the request will be
-                                  serviced in microseconds (this takes the client-supplied
-                                  offset and CLOCK_TARGET_OFFSET into account) */
+   int64_t media_time_adj;   /**< adjusted media-time at which the request will
+                                  be serviced in microseconds (this takes
+                                  CLOCK_TARGET_OFFSET into account) */
 } MMAL_CLOCK_REQUEST_T;
 
 typedef struct MMAL_CLOCK_PRIVATE_T
@@ -109,14 +108,14 @@ typedef struct MMAL_CLOCK_PRIVATE_T
 
    MMAL_BOOL_T is_active;     /**< TRUE -> media-time is advancing */
 
+   MMAL_BOOL_T scheduling;    /**< TRUE -> client request scheduling is enabled */
    MMAL_BOOL_T stop_thread;
    VCOS_SEMAPHORE_T event;
-   VCOS_THREAD_T thread;
+   VCOS_THREAD_T thread;      /**< processing thread for client requests */
+   MMAL_TIMER_T timer;        /**< used for scheduling client requests */
 
    VCOS_MUTEX_T lock;         /**< lock access to the request lists */
 
-   MMAL_TIMER_T timer;        /**< used for scheduling client requests */
-
    int32_t scale;             /**< media-time scale factor (Q16 format) */
    int32_t scale_inv;         /**< 1/scale (Q16 format) */
    MMAL_RATIONAL_T scale_rational;
@@ -125,7 +124,6 @@ typedef struct MMAL_CLOCK_PRIVATE_T
 
    int64_t  average_ref_diff; /**< media-time moving average adjustment */
    int64_t  media_time;       /**< current local media-time in microseconds */
-   int64_t  media_time_offset;/**< media-time offset in microseconds */
    uint32_t media_time_frac;  /**< media-time fraction in microseconds (Q24 format) */
    int64_t  wall_time;        /**< current local wall-time (microseconds) */
    uint32_t rtc_at_update;    /**< real-time clock value at local time update (microseconds) */
@@ -229,28 +227,31 @@ static inline void mmal_clock_timer_cancel(MMAL_TIMER_T *timer)
  * Clock module private functions
  *****************************************************************************/
 /* Update the internal wall-time and media-time */
-static void mmal_clock_update_local_time(MMAL_CLOCK_PRIVATE_T *private)
+static void mmal_clock_update_local_time_locked(MMAL_CLOCK_PRIVATE_T *private)
 {
    uint32_t time_now = vcos_getmicrosecs();
    uint32_t time_diff = (time_now > private->rtc_at_update) ? (time_now - private->rtc_at_update) : 0;
 
    private->wall_time += time_diff;
 
-   /* Only update the media-time if the clock is active */
-   if (private->is_active)
-   {
-      /* For small clock scale values (i.e. slow motion), the media-time increment
-       * could potentially be rounded down when doing lots of updates, so also keep
-       * track of the fractional increment. */
-      int64_t media_diff = ((int64_t)time_diff) * (int64_t)(private->scale << 8) + private->media_time_frac;
+   /* For small clock scale values (i.e. slow motion), the media-time increment
+    * could potentially be rounded down when doing lots of updates, so also keep
+    * track of the fractional increment. */
+   int64_t media_diff = ((int64_t)time_diff) * (int64_t)(private->scale << 8) + private->media_time_frac;
 
-      private->media_time += media_diff >> 24;
-      private->media_time_frac = media_diff & ((1<<24)-1);
-   }
+   private->media_time += media_diff >> 24;
+   private->media_time_frac = media_diff & ((1<<24)-1);
 
    private->rtc_at_update = time_now;
 }
 
+/* Return the current local media-time */
+static int64_t mmal_clock_media_time_get_locked(MMAL_CLOCK_PRIVATE_T *private)
+{
+   mmal_clock_update_local_time_locked(private);
+   return private->media_time;
+}
+
 /* Comparison function used for inserting a request into
  * the list of pending requests when clock scale is positive. */
 static int mmal_clock_request_compare_pos(MMAL_LIST_ELEMENT_T *lhs, MMAL_LIST_ELEMENT_T *rhs)
@@ -334,7 +335,7 @@ static void mmal_clock_process_requests(MMAL_CLOCK_PRIVATE_T *private)
    /* Detect discontinuity */
    if (private->media_time_at_timer != 0)
    {
-      media_time_now = mmal_clock_media_time_get(&private->clock);
+      media_time_now = mmal_clock_media_time_get_locked(private);
       /* Currently only applied to forward speeds */
       if (private->scale > 0 &&
           media_time_now + private->discont_threshold < private->media_time_at_timer)
@@ -357,12 +358,10 @@ static void mmal_clock_process_requests(MMAL_CLOCK_PRIVATE_T *private)
    next = (MMAL_CLOCK_REQUEST_T*)mmal_list_pop_front(pending);
    while (next)
    {
-      media_time_now = mmal_clock_media_time_get(&private->clock);
+      media_time_now = mmal_clock_media_time_get_locked(private);
 
       if (private->discont_expiry != 0 && private->wall_time > private->discont_expiry)
-      {
          private->discont_expiry = 0;
-      }
 
       /* Fire the request if it matches the pending discontinuity or if its requested media time
        * has been reached. */
@@ -405,10 +404,11 @@ static void mmal_clock_process_requests(MMAL_CLOCK_PRIVATE_T *private)
    UNLOCK(private);
 }
 
-/* Trigger the worker thread */
+/* Trigger the worker thread (if present) */
 static void mmal_clock_wake_thread(MMAL_CLOCK_PRIVATE_T *private)
 {
-   vcos_semaphore_post(&private->event);
+   if (private->scheduling)
+      vcos_semaphore_post(&private->event);
 }
 
 /* Stop the worker thread */
@@ -439,12 +439,83 @@ static void* mmal_clock_worker_thread(void *ctx)
    return NULL;
 }
 
+/* Create scheduling resources */
+static MMAL_STATUS_T mmal_clock_create_scheduling(MMAL_CLOCK_PRIVATE_T *private)
+{
+   unsigned int i;
+   MMAL_BOOL_T timer_status = MMAL_FALSE;
+   VCOS_STATUS_T event_status = VCOS_EINVAL;
+   VCOS_UNSIGNED priority;
+
+   timer_status = mmal_clock_timer_create(&private->timer, private);
+   if (!timer_status)
+   {
+      LOG_ERROR("failed to create timer %p", private);
+      goto error;
+   }
+
+   event_status = vcos_semaphore_create(&private->event, "mmal-clock sema", 0);
+   if (event_status != VCOS_SUCCESS)
+   {
+      LOG_ERROR("failed to create event semaphore %d", event_status);
+      goto error;
+   }
+
+   private->request.list_free = mmal_list_create();
+   private->request.list_pending = mmal_list_create();
+   if (!private->request.list_free || !private->request.list_pending)
+   {
+      LOG_ERROR("failed to create list %p %p", private->request.list_free, private->request.list_pending);
+      goto error;
+   }
+
+   /* Populate the list of available request slots */
+   for (i = 0; i < CLOCK_REQUEST_SLOTS; ++i)
+      mmal_list_push_back(private->request.list_free, &private->request.pool[i].link);
+
+   if (vcos_thread_create(&private->thread, "mmal-clock thread", NULL,
+                          mmal_clock_worker_thread, private) != VCOS_SUCCESS)
+   {
+      LOG_ERROR("failed to create worker thread");
+      goto error;
+   }
+   priority = vcos_thread_get_priority(&private->thread);
+   vcos_thread_set_priority(&private->thread, 1 | (priority & VCOS_AFFINITY_MASK));
+
+   private->scheduling = MMAL_TRUE;
+
+   return MMAL_SUCCESS;
+
+error:
+   if (event_status == VCOS_SUCCESS) vcos_semaphore_delete(&private->event);
+   if (timer_status) mmal_clock_timer_destroy(&private->timer);
+   if (private->request.list_free) mmal_list_destroy(private->request.list_free);
+   if (private->request.list_pending) mmal_list_destroy(private->request.list_pending);
+   return MMAL_ENOSPC;
+}
+
+/* Destroy all scheduling resources */
+static void mmal_clock_destroy_scheduling(MMAL_CLOCK_PRIVATE_T *private)
+{
+   mmal_clock_stop_thread(private);
+
+   mmal_clock_request_flush(&private->clock);
+
+   mmal_list_destroy(private->request.list_free);
+   mmal_list_destroy(private->request.list_pending);
+
+   vcos_semaphore_delete(&private->event);
+
+   mmal_clock_timer_destroy(&private->timer);
+}
+
 /* Start the media-time */
 static void mmal_clock_start(MMAL_CLOCK_T *clock)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
 
    private->is_active = MMAL_TRUE;
+
    mmal_clock_wake_thread(private);
 }
 
@@ -454,6 +525,14 @@ static void mmal_clock_stop(MMAL_CLOCK_T *clock)
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
 
    private->is_active = MMAL_FALSE;
+
+   mmal_clock_wake_thread(private);
+}
+
+static int mmal_clock_is_paused(MMAL_CLOCK_T *clock)
+{
+   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
+   return private->scale == 0;
 }
 
 /*****************************************************************************
@@ -462,12 +541,8 @@ static void mmal_clock_stop(MMAL_CLOCK_T *clock)
 /* Create new clock instance */
 MMAL_STATUS_T mmal_clock_create(MMAL_CLOCK_T **clock)
 {
-   unsigned int i, size = sizeof(MMAL_CLOCK_PRIVATE_T);
-   MMAL_BOOL_T timer_status = MMAL_FALSE;
-   VCOS_STATUS_T lock_status = VCOS_EINVAL;
-   VCOS_STATUS_T event_status = VCOS_EINVAL;
-   MMAL_RATIONAL_T scale = { 1, 0 };
-   VCOS_UNSIGNED priority;
+   unsigned int size = sizeof(MMAL_CLOCK_PRIVATE_T);
+   MMAL_RATIONAL_T scale = { 1, 1 };
    MMAL_CLOCK_PRIVATE_T *private;
 
    /* Sanity checking */
@@ -481,33 +556,11 @@ MMAL_STATUS_T mmal_clock_create(MMAL_CLOCK_T **clock)
       return MMAL_ENOMEM;
    }
 
-   timer_status = mmal_clock_timer_create(&private->timer, private);
-   if (!timer_status)
-   {
-      LOG_ERROR("failed to create timer %p", private);
-      goto error;
-   }
-
-   event_status = vcos_semaphore_create(&private->event, "mmal-clock sema", 0);
-   if (event_status != VCOS_SUCCESS)
+   if (vcos_mutex_create(&private->lock, "mmal-clock lock") != VCOS_SUCCESS)
    {
-      LOG_ERROR("failed to create event semaphore %d", event_status);
-      goto error;
-   }
-
-   lock_status = vcos_mutex_create(&private->lock, "mmal-clock lock");
-   if (lock_status != VCOS_SUCCESS)
-   {
-      LOG_ERROR("failed to create lock mutex %d", lock_status);
-      goto error;
-   }
-
-   private->request.list_free = mmal_list_create();
-   private->request.list_pending = mmal_list_create();
-   if (!private->request.list_free || !private->request.list_pending)
-   {
-      LOG_ERROR("failed to create list %p %p", private->request.list_free, private->request.list_pending);
-      goto error;
+      LOG_ERROR("failed to create lock mutex");
+      vcos_free(private);
+      return MMAL_ENOSPC;
    }
 
    /* Set the default threshold values */
@@ -518,33 +571,11 @@ MMAL_STATUS_T mmal_clock_create(MMAL_CLOCK_T **clock)
    private->request_threshold      = 0;
    private->request_threshold_enable = MMAL_FALSE;
 
-   if (vcos_thread_create(&private->thread, "mmal-clock thread", NULL,
-                          mmal_clock_worker_thread, private) != VCOS_SUCCESS)
-   {
-      LOG_ERROR("failed to create worker thread");
-      goto error;
-   }
-   priority = vcos_thread_get_priority(&private->thread);
-   vcos_thread_set_priority(&private->thread, 1 | (priority & VCOS_AFFINITY_MASK));
-
-   /* Populate the list of available request slots */
-   for (i = 0; i < CLOCK_REQUEST_SLOTS; ++i)
-      mmal_list_push_back(private->request.list_free, &private->request.pool[i].link);
-
    /* Default scale = 1.0, i.e. normal playback speed */
    mmal_clock_scale_set(&private->clock, scale);
 
    *clock = &private->clock;
    return MMAL_SUCCESS;
-
-error:
-   if (lock_status == VCOS_SUCCESS) vcos_mutex_delete(&private->lock);
-   if (event_status == VCOS_SUCCESS) vcos_semaphore_delete(&private->event);
-   if (timer_status) mmal_clock_timer_destroy(&private->timer);
-   if (private->request.list_free) mmal_list_destroy(private->request.list_free);
-   if (private->request.list_pending) mmal_list_destroy(private->request.list_pending);
-   vcos_free(private);
-   return MMAL_ENOSPC;
 }
 
 /* Destroy a clock instance */
@@ -552,67 +583,76 @@ MMAL_STATUS_T mmal_clock_destroy(MMAL_CLOCK_T *clock)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
 
-   mmal_clock_stop_thread(private);
-
-   mmal_clock_request_flush(clock);
-
-   mmal_list_destroy(private->request.list_free);
-   mmal_list_destroy(private->request.list_pending);
-
-   mmal_clock_timer_destroy(&private->timer);
+   if (private->scheduling)
+      mmal_clock_destroy_scheduling(private);
 
    vcos_mutex_delete(&private->lock);
 
-   vcos_semaphore_delete(&private->event);
-
    vcos_free(private);
 
    return MMAL_SUCCESS;
 }
 
 /* Add new client request to list of pending requests */
-MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time, int64_t offset,
+MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time,
       MMAL_CLOCK_REQUEST_CB cb, void *cb_data, MMAL_CLOCK_VOID_FP priv)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
    MMAL_CLOCK_REQUEST_T *request;
-   MMAL_BOOL_T success;
+   MMAL_BOOL_T wake_thread = MMAL_FALSE;
    int64_t media_time_now;
 
-   LOG_TRACE("media time %"PRIi64" offset %"PRIi64, media_time, offset);
+   LOG_TRACE("media time %"PRIi64, media_time);
 
-   /* Drop the request if request_threshold_enable and the frame exceeds the request threshold */
-   media_time_now = mmal_clock_media_time_get(&private->clock);
    LOCK(private);
-   if(private->request_threshold_enable && (media_time > (media_time_now + private->request_threshold))) {
+
+   media_time_now = mmal_clock_media_time_get_locked(private);
+
+   /* Drop the request if request_threshold_enable and the frame exceeds the request threshold */
+   if (private->request_threshold_enable && (media_time > (media_time_now + private->request_threshold)))
+   {
       LOG_TRACE("dropping request: media time %"PRIi64" now %"PRIi64, media_time, media_time_now);
       UNLOCK(private);
       return MMAL_ECORRUPT;
    }
-   UNLOCK(private);
+
+   /* The clock module is usually only used for time-keeping, so all the
+    * objects needed to process client requests are not allocated by default
+    * and need to be created on the first client request received */
+   if (!private->scheduling)
+   {
+      if (mmal_clock_create_scheduling(private) != MMAL_SUCCESS)
+      {
+         LOG_ERROR("failed to create scheduling objects");
+         UNLOCK(private);
+         return MMAL_ENOSPC;
+      }
+   }
+
    request = (MMAL_CLOCK_REQUEST_T*)mmal_list_pop_front(private->request.list_free);
    if (request == NULL)
    {
       LOG_ERROR("no more free clock request slots");
+      UNLOCK(private);
       return MMAL_ENOSPC;
    }
 
    request->cb = cb;
    request->cb_data = cb_data;
    request->priv = priv;
-   request->offset = offset;
    request->media_time = media_time;
-   request->media_time_adj = media_time - (int64_t)(private->scale * (request->offset + CLOCK_TARGET_OFFSET) >> 16);
+   request->media_time_adj = media_time - (int64_t)(private->scale * CLOCK_TARGET_OFFSET >> 16);
+
+   if (mmal_clock_request_insert(private, request))
+      wake_thread = private->is_active;
 
-   LOCK(private);
-   success = mmal_clock_request_insert(private, request);
    UNLOCK(private);
 
    /* Notify the worker thread */
-   if (success)
+   if (wake_thread)
       mmal_clock_wake_thread(private);
 
-   return success ? MMAL_SUCCESS : MMAL_EINVAL;
+   return MMAL_SUCCESS;
 }
 
 /* Flush all pending requests */
@@ -621,7 +661,8 @@ MMAL_STATUS_T mmal_clock_request_flush(MMAL_CLOCK_T *clock)
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
 
    LOCK(private);
-   mmal_clock_request_flush_locked(private, MMAL_TIME_UNKNOWN);
+   if (private->scheduling)
+      mmal_clock_request_flush_locked(private, MMAL_TIME_UNKNOWN);
    UNLOCK(private);
 
    return MMAL_SUCCESS;
@@ -634,8 +675,29 @@ MMAL_STATUS_T mmal_clock_media_time_set(MMAL_CLOCK_T *clock, int64_t media_time)
    MMAL_BOOL_T wake_thread = MMAL_TRUE;
    int64_t time_diff;
 
+   LOCK(private);
+
+   if (!private->is_active)
+   {
+      uint32_t time_now = vcos_getmicrosecs();
+      private->wall_time = time_now;
+      private->media_time = media_time;
+      private->media_time_frac = 0;
+      private->rtc_at_update = time_now;
+
+      UNLOCK(private);
+      return MMAL_SUCCESS;
+   }
+
+   if (mmal_clock_is_paused(clock))
+   {
+      LOG_TRACE("clock is paused; ignoring update");
+      UNLOCK(private);
+      return MMAL_SUCCESS;
+   }
+
    /* Reset the local media-time with the given time reference */
-   mmal_clock_update_local_time(private);
+   mmal_clock_update_local_time_locked(private);
 
    time_diff = private->media_time - media_time;
    if (time_diff >  private->update_threshold_upper ||
@@ -665,23 +727,11 @@ MMAL_STATUS_T mmal_clock_media_time_set(MMAL_CLOCK_T *clock, int64_t media_time)
       }
    }
 
+   UNLOCK(private);
+
    if (wake_thread)
       mmal_clock_wake_thread(private);
 
-   return wake_thread ? MMAL_SUCCESS : MMAL_EINVAL;
-}
-
-/* Set a media-time offset */
-MMAL_STATUS_T mmal_clock_media_time_offset_set(MMAL_CLOCK_T *clock, int64_t offset)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-
-   LOG_TRACE("new offset %"PRIi64, offset);
-
-   private->media_time_offset = offset;
-
-   mmal_clock_wake_thread(private);
-
    return MMAL_SUCCESS;
 }
 
@@ -692,10 +742,10 @@ MMAL_STATUS_T mmal_clock_scale_set(MMAL_CLOCK_T *clock, MMAL_RATIONAL_T scale)
 
    LOG_TRACE("new scale %d/%d", scale.num, scale.den);
 
-   mmal_clock_update_local_time(private);
-
    LOCK(private);
 
+   mmal_clock_update_local_time_locked(private);
+
    private->scale_rational = scale;
    private->scale = mmal_rational_to_fixed_16_16(scale);
 
@@ -738,17 +788,14 @@ MMAL_RATIONAL_T mmal_clock_scale_get(MMAL_CLOCK_T *clock)
 /* Return the current local media-time */
 int64_t mmal_clock_media_time_get(MMAL_CLOCK_T *clock)
 {
+   int64_t media_time;
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
 
-   mmal_clock_update_local_time(private);
-
-   return private->media_time + (private->scale * private->media_time_offset >> 16);
-}
+   LOCK(private);
+   media_time = mmal_clock_media_time_get_locked(private);
+   UNLOCK(private);
 
-/* Return the media-time offset */
-int64_t mmal_clock_media_time_offset_get(MMAL_CLOCK_T *clock)
-{
-   return ((MMAL_CLOCK_PRIVATE_T*)clock)->media_time_offset;
+   return media_time;
 }
 
 /* Get the clock's state */
@@ -758,7 +805,7 @@ MMAL_BOOL_T mmal_clock_is_active(MMAL_CLOCK_T *clock)
 }
 
 /* Get the clock's media-time update threshold values */
-MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold)
+MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_UPDATE_THRESHOLD_T *update_threshold)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
 
@@ -771,7 +818,7 @@ MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETE
 }
 
 /* Set the clock's media-time update threshold values */
-MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold)
+MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_UPDATE_THRESHOLD_T *update_threshold)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
 
@@ -787,7 +834,7 @@ MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PA
 }
 
 /* Get the clock's discontinuity threshold values */
-MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont)
+MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_DISCONT_THRESHOLD_T *discont)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
 
@@ -800,7 +847,7 @@ MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMET
 }
 
 /* Set the clock's discontinuity threshold values */
-MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont)
+MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_DISCONT_THRESHOLD_T *discont)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
 
@@ -816,7 +863,7 @@ MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_P
 }
 
 /* Get the clock's request threshold values */
-MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req)
+MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_REQUEST_THRESHOLD_T *req)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
 
@@ -829,7 +876,7 @@ MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMET
 }
 
 /* Set the clock's request threshold values */
-MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req)
+MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_REQUEST_THRESHOLD_T *req)
 {
    MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
 
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock_private.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock_private.h
index c90461d..25ebc87 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock_private.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock_private.h
@@ -74,15 +74,13 @@ typedef void (*MMAL_CLOCK_REQUEST_CB)(MMAL_CLOCK_T *clock, int64_t media_time, v
  *
  * @param clock      The clock
  * @param media_time The media-time at which the callback should be invoked (microseconds)
- * @param offset     Time offset (in microseconds) applied to the media-time. This can be used
- *                   to schedule the request slightly in advance of the media-time.
  * @param cb         Callback to invoke
  * @param cb_data    Client-supplied callback data
  * @param priv       Function pointer used by the framework
  *
  * @return MMAL_SUCCESS on success
  */
-MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time, int64_t offset,
+MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time,
                                      MMAL_CLOCK_REQUEST_CB cb, void *cb_data, MMAL_CLOCK_VOID_FP priv);
 
 /** Remove all previously registered clock requests.
@@ -102,15 +100,6 @@ MMAL_STATUS_T mmal_clock_request_flush(MMAL_CLOCK_T *clock);
  */
 MMAL_STATUS_T mmal_clock_media_time_set(MMAL_CLOCK_T *clock, int64_t media_time);
 
-/** Update the clock's media-time offset.
- *
- * @param clock      The clock to update
- * @param media_time New media-time offset to be applied (microseconds)
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_media_time_offset_set(MMAL_CLOCK_T *clock, int64_t offset);
-
 /** Set the clock's scale.
  *
  * @param clock      The clock
@@ -146,14 +135,6 @@ MMAL_RATIONAL_T mmal_clock_scale_get(MMAL_CLOCK_T *clock);
  */
 int64_t mmal_clock_media_time_get(MMAL_CLOCK_T *clock);
 
-/** Get the clock's media-time offset.
- *
- * @param clock      The clock to query
- *
- * @return Current media-time offset in microseconds
- */
-int64_t mmal_clock_media_time_offset_get(MMAL_CLOCK_T *clock);
-
 /** Get the clock's state.
  *
  * @param clock      The clock to query
@@ -169,7 +150,7 @@ MMAL_BOOL_T mmal_clock_is_active(MMAL_CLOCK_T *clock);
  *
  * @return MMAL_SUCCESS on success
  */
-MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold);
+MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_UPDATE_THRESHOLD_T *update_threshold);
 
 /** Set the clock's media-time update threshold values.
  *
@@ -178,7 +159,7 @@ MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETE
  *
  * @return MMAL_SUCCESS on success
  */
-MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold);
+MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_UPDATE_THRESHOLD_T *update_threshold);
 
 /** Get the clock's discontinuity threshold values.
  *
@@ -187,7 +168,7 @@ MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PA
  *
  * @return MMAL_SUCCESS on success
  */
-MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont);
+MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_DISCONT_THRESHOLD_T *discont);
 
 /** Set the clock's discontinuity threshold values.
  *
@@ -196,7 +177,7 @@ MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMET
  *
  * @return MMAL_SUCCESS on success
  */
-MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont);
+MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_DISCONT_THRESHOLD_T *discont);
 
 /** Get the clock's request threshold values.
  *
@@ -205,7 +186,7 @@ MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_P
  *
  * @return MMAL_SUCCESS on success
  */
-MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req);
+MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_REQUEST_THRESHOLD_T *req);
 
 /** Set the clock's request threshold values.
  *
@@ -214,7 +195,7 @@ MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMET
  *
  * @return MMAL_SUCCESS on success
  */
-MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req);
+MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_REQUEST_THRESHOLD_T *req);
 
 #ifdef __cplusplus
 }
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component.c
index 849a350..c621ca8 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component.c
@@ -44,7 +44,7 @@ typedef struct
 
    /** Action thread */
    VCOS_THREAD_T action_thread;
-   VCOS_SEMAPHORE_T action_sema;
+   VCOS_EVENT_T action_event;
    VCOS_MUTEX_T action_mutex;
    MMAL_BOOL_T action_quit;
 
@@ -96,6 +96,7 @@ static MMAL_STATUS_T mmal_component_create_core(const char *name,
    (*component)->priv = (MMAL_COMPONENT_PRIVATE_T *)private;
    (*component)->name = component_name= (char *)&((MMAL_COMPONENT_CORE_PRIVATE_T *)(*component)->priv)[1];
    memcpy(component_name, name, name_length);
+   /* coverity[missing_lock] Component and mutex have just been created. No need to lock yet */
    (*component)->priv->refcount = 1;
    (*component)->priv->priority = VCOS_THREAD_PRI_NORMAL;
 
@@ -358,7 +359,7 @@ MMAL_STATUS_T mmal_component_release(MMAL_COMPONENT_T *component)
 MMAL_STATUS_T mmal_component_enable(MMAL_COMPONENT_T *component)
 {
    MMAL_COMPONENT_CORE_PRIVATE_T *private;
-   MMAL_STATUS_T status;
+   MMAL_STATUS_T status = MMAL_ENOSYS;
    unsigned int i;
 
    if(!component)
@@ -377,13 +378,21 @@ MMAL_STATUS_T mmal_component_enable(MMAL_COMPONENT_T *component)
       return MMAL_SUCCESS;
    }
 
-   status = component->priv->pf_enable(component);
+   if (component->priv->pf_enable)
+      status = component->priv->pf_enable(component);
 
-   /* Resume all input / output ports */
-   for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
-      status = mmal_port_pause(component->input[i], MMAL_FALSE);
-   for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
-      status = mmal_port_pause(component->output[i], MMAL_FALSE);
+   /* If the component does not support enable/disable, we handle that
+    * in the core itself */
+   if (status == MMAL_ENOSYS)
+   {
+      status = MMAL_SUCCESS;
+
+      /* Resume all input / output ports */
+      for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
+         status = mmal_port_pause(component->input[i], MMAL_FALSE);
+      for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
+         status = mmal_port_pause(component->output[i], MMAL_FALSE);
+   }
 
    if (status == MMAL_SUCCESS)
       component->is_enabled = 1;
@@ -397,7 +406,7 @@ MMAL_STATUS_T mmal_component_enable(MMAL_COMPONENT_T *component)
 MMAL_STATUS_T mmal_component_disable(MMAL_COMPONENT_T *component)
 {
    MMAL_COMPONENT_CORE_PRIVATE_T *private;
-   MMAL_STATUS_T status;
+   MMAL_STATUS_T status = MMAL_ENOSYS;
    unsigned int i;
 
    if (!component)
@@ -416,13 +425,21 @@ MMAL_STATUS_T mmal_component_disable(MMAL_COMPONENT_T *component)
       return MMAL_SUCCESS;
    }
 
-   status = component->priv->pf_disable(component);
+   if (component->priv->pf_disable)
+      status = component->priv->pf_disable(component);
 
-   /* Pause all input / output ports */
-   for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
-      status = mmal_port_pause(component->input[i], MMAL_TRUE);
-   for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
-      status = mmal_port_pause(component->output[i], MMAL_TRUE);
+   /* If the component does not support enable/disable, we handle that
+    * in the core itself */
+   if (status == MMAL_ENOSYS)
+   {
+      status = MMAL_SUCCESS;
+
+      /* Pause all input / output ports */
+      for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
+         status = mmal_port_pause(component->input[i], MMAL_TRUE);
+      for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
+         status = mmal_port_pause(component->output[i], MMAL_TRUE);
+   }
 
    if (status == MMAL_SUCCESS)
       component->is_enabled = 0;
@@ -534,7 +551,7 @@ static void *mmal_component_action_thread_func(void *arg)
 
    while (1)
    {
-      status = vcos_semaphore_wait(&private->action_sema);
+      status = vcos_event_wait(&private->action_event);
 
       if (status == VCOS_EAGAIN)
          continue;
@@ -561,14 +578,14 @@ MMAL_STATUS_T mmal_component_action_register(MMAL_COMPONENT_T *component,
    if (private->pf_action)
       return MMAL_EINVAL;
 
-   status = vcos_semaphore_create(&private->action_sema, component->name, 0);
+   status = vcos_event_create(&private->action_event, component->name);
    if (status != VCOS_SUCCESS)
       return MMAL_ENOMEM;
 
    status = vcos_mutex_create(&private->action_mutex, component->name);
    if (status != VCOS_SUCCESS)
    {
-      vcos_semaphore_delete(&private->action_sema);
+      vcos_event_delete(&private->action_event);
       return MMAL_ENOMEM;
    }
 
@@ -580,7 +597,7 @@ MMAL_STATUS_T mmal_component_action_register(MMAL_COMPONENT_T *component,
    if (status != VCOS_SUCCESS)
    {
       vcos_mutex_delete(&private->action_mutex);
-      vcos_semaphore_delete(&private->action_sema);
+      vcos_event_delete(&private->action_event);
       return MMAL_ENOMEM;
    }
 
@@ -597,9 +614,9 @@ MMAL_STATUS_T mmal_component_action_deregister(MMAL_COMPONENT_T *component)
       return MMAL_EINVAL;
 
    private->action_quit = 1;
-   vcos_semaphore_post(&private->action_sema);
+   vcos_event_signal(&private->action_event);
    vcos_thread_join(&private->action_thread, NULL);
-   vcos_semaphore_delete(&private->action_sema);
+   vcos_event_delete(&private->action_event);
    vcos_mutex_delete(&private->action_mutex);
    private->pf_action = NULL;
    private->action_quit = 0;
@@ -614,7 +631,7 @@ MMAL_STATUS_T mmal_component_action_trigger(MMAL_COMPONENT_T *component)
    if (!private->pf_action)
       return MMAL_EINVAL;
 
-   vcos_semaphore_post(&private->action_sema);
+   vcos_event_signal(&private->action_event);
    return MMAL_SUCCESS;
 }
 
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component_private.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component_private.h
index 6699a02..26c7a7e 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component_private.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component_private.h
@@ -28,6 +28,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef MMAL_COMPONENT_PRIVATE_H
 #define MMAL_COMPONENT_PRIVATE_H
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #define MMAL_VIDEO_DECODE  "video_decode"
 #define MMAL_VIDEO_ENCODE  "video_encode"
 #define MMAL_VIDEO_RENDER  "video_render"
@@ -158,4 +162,8 @@ MMAL_STATUS_T mmal_component_create_with_constructor(const char *name,
 void mmal_component_supplier_register(const char *prefix,
                                       MMAL_COMPONENT_SUPPLIER_FUNCTION_T create_fn);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* MMAL_COMPONENT_PRIVATE_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_events.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_events.c
index 4b5f58f..80607f7 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_events.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_events.c
@@ -39,7 +39,7 @@ MMAL_EVENT_FORMAT_CHANGED_T *mmal_event_format_changed_get(MMAL_BUFFER_HEADER_T
    size = sizeof(MMAL_EVENT_FORMAT_CHANGED_T);
    size += sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T);
 
-   if (buffer->cmd != MMAL_EVENT_FORMAT_CHANGED || !buffer || buffer->length < size)
+   if (!buffer || buffer->cmd != MMAL_EVENT_FORMAT_CHANGED || buffer->length < size)
       return 0;
 
    event = (MMAL_EVENT_FORMAT_CHANGED_T *)buffer->data;
@@ -74,3 +74,65 @@ MMAL_STATUS_T mmal_event_error_send(MMAL_COMPONENT_T *component, MMAL_STATUS_T e
 
    return MMAL_SUCCESS;
 }
+
+MMAL_STATUS_T mmal_event_eos_send(MMAL_PORT_T *port)
+{
+   MMAL_EVENT_END_OF_STREAM_T *event;
+   MMAL_BUFFER_HEADER_T *buffer;
+   MMAL_STATUS_T status;
+
+   if(!port)
+   {
+      LOG_ERROR("invalid port");
+      return MMAL_EINVAL;
+   }
+
+   status = mmal_port_event_get(port->component->control, &buffer, MMAL_EVENT_EOS);
+   if (status != MMAL_SUCCESS)
+   {
+      LOG_ERROR("event not available for port %s %p, result %d", port->name, port, status);
+      return status;
+   }
+
+   buffer->length = sizeof(*event);
+   event = (MMAL_EVENT_END_OF_STREAM_T *)buffer->data;
+   event->port_type = port->type;
+   event->port_index = port->index;
+   mmal_port_event_send(port->component->control, buffer);
+
+   return MMAL_SUCCESS;
+}
+
+MMAL_STATUS_T mmal_event_forward(MMAL_BUFFER_HEADER_T *event, MMAL_PORT_T *port)
+{
+   MMAL_BUFFER_HEADER_T *buffer;
+   MMAL_STATUS_T status;
+
+   if(!port || port->type != MMAL_PORT_TYPE_OUTPUT)
+   {
+      LOG_ERROR("invalid port");
+      return MMAL_EINVAL;
+   }
+
+   status = mmal_port_event_get(port->component->control, &buffer, event->cmd);
+   if (status != MMAL_SUCCESS)
+   {
+      LOG_ERROR("event not available for port %s %p, result %d", port->name, port, status);
+      return status;
+   }
+
+   if (buffer->alloc_size < event->length)
+   {
+      LOG_ERROR("event buffer too small (%i/%i)", buffer->alloc_size, event->length);
+      mmal_buffer_header_release(buffer);
+      return MMAL_ENOSPC;
+   }
+
+   memcpy(buffer->data, event->data, event->length);
+   buffer->length = event->length;
+   buffer->offset = event->offset;
+   buffer->flags = event->flags;
+   buffer->pts = event->pts;
+   mmal_port_event_send(port->component->control, buffer);
+   return MMAL_SUCCESS;
+}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_format.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_format.c
index 71606ff..7b8e25e 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_format.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_format.c
@@ -27,6 +27,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "mmal_types.h"
 #include "mmal_format.h"
+#include "util/mmal_util_rational.h"
 
 #define MMAL_ES_FORMAT_MAGIC MMAL_FOURCC('m','a','g','f')
 #define EXTRADATA_SIZE_DEFAULT 32
@@ -128,9 +129,9 @@ uint32_t mmal_format_compare(MMAL_ES_FORMAT_T *fmt1, MMAL_ES_FORMAT_T *fmt2)
          result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION;
       if (memcmp(&video1->crop, &video2->crop, sizeof(video1->crop)))
          result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING;
-      if (memcmp(&video1->par, &video2->par, sizeof(video1->par)))
+      if (!mmal_rational_equal(video1->par, video2->par))
          result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO;
-      if (memcmp(&video1->frame_rate, &video2->frame_rate, sizeof(video1->frame_rate)))
+      if (!mmal_rational_equal(video1->frame_rate, video2->frame_rate))
          result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE;
       if (video1->color_space != video2->color_space)
          result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE;
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port.c
index 539ac8e..d7b00c1 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port.c
@@ -747,11 +747,14 @@ MMAL_STATUS_T mmal_port_send_buffer(MMAL_PORT_T *port,
       buffer->length = 0;
    }
 
+   /* coverity[lock] transit_sema is used for signalling, and is not a lock */
+   /* coverity[lock_order] since transit_sema is not a lock, there is no ordering conflict */
    IN_TRANSIT_INCREMENT(port);
 
    if (port->priv->core->is_paused)
    {
       /* Add buffer to our internal queue */
+      buffer->next = NULL;
       *port->priv->core->queue_last = buffer;
       port->priv->core->queue_last = &buffer->next;
    }
@@ -790,8 +793,17 @@ MMAL_STATUS_T mmal_port_flush(MMAL_PORT_T *port)
    if (!port->priv->pf_flush)
       return MMAL_ENOSYS;
 
+   /* N.B. must take action lock *before* sending lock */
    mmal_component_action_lock(port->component);
    LOCK_SENDING(port);
+
+   if (!port->is_enabled)
+   {
+      UNLOCK_SENDING(port);
+      mmal_component_action_unlock(port->component);
+      return MMAL_SUCCESS;
+   }
+
    status = port->priv->pf_flush(port);
    if (status == MMAL_SUCCESS)
    {
@@ -800,6 +812,7 @@ MMAL_STATUS_T mmal_port_flush(MMAL_PORT_T *port)
       port->priv->core->queue_first = 0;
       port->priv->core->queue_last = &port->priv->core->queue_first;
    }
+
    UNLOCK_SENDING(port);
    mmal_component_action_unlock(port->component);
 
@@ -1268,11 +1281,19 @@ static MMAL_STATUS_T mmal_port_connect_default(MMAL_PORT_T *port, MMAL_PORT_T *o
 /** Connected input port buffer callback */
 static void mmal_port_connected_input_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
-   MMAL_PARAM_UNUSED(port);
-
    LOG_TRACE("buffer %p from connected input port %p: data %p, alloc_size %u, length %u",
              buffer, port, buffer->data, buffer->alloc_size, buffer->length);
 
+   /* Clock ports are bi-directional and a buffer coming from an "input"
+    * clock port can potentially have valid payload data, in which case
+    * it should be sent directly to the connected port. */
+   if (port->type == MMAL_PORT_TYPE_CLOCK && buffer->length)
+   {
+      MMAL_PORT_T* connected_port = port->priv->core->connected_port;
+      mmal_port_send_buffer(connected_port, buffer);
+      return;
+   }
+
    /* Simply release buffer back into pool for re-use */
    mmal_buffer_header_release(buffer);
 }
@@ -1348,14 +1369,6 @@ static MMAL_BOOL_T mmal_port_connected_pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HE
    LOG_TRACE("released buffer %p, data %p alloc_size %u length %u",
              buffer, buffer->data, buffer->alloc_size, buffer->length);
 
-   /* Reset buffer header */
-   buffer->cmd = 0;
-   buffer->length = 0;
-   buffer->offset = 0;
-   buffer->flags = 0;
-   buffer->pts = 0;
-   buffer->dts = 0;
-
    /* Pipe the buffer back to the output port */
    status = mmal_port_send_buffer(port, buffer);
 
@@ -1488,3 +1501,8 @@ MMAL_STATUS_T mmal_port_pause(MMAL_PORT_T *port, MMAL_BOOL_T pause)
    UNLOCK_SENDING(port);
    return status;
 }
+
+MMAL_BOOL_T mmal_port_is_connected(MMAL_PORT_T *port)
+{
+   return !!port->priv->core->connected_port;
+}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_clock.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_clock.c
index 8f71513..1eb7d10 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_clock.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_clock.c
@@ -36,17 +36,18 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #endif
 
 /** Minimum number of buffers required on a clock port */
-#define MMAL_PORT_CLOCK_BUFFERS_MIN  8
+#define MMAL_PORT_CLOCK_BUFFERS_MIN  16
 
 /** Private clock port context */
-typedef struct MMAL_PORT_MODULE_T
+typedef struct MMAL_PORT_CLOCK_T
 {
    MMAL_PORT_CLOCK_EVENT_CB event_cb; /**< callback for notifying the component of clock events */
    MMAL_QUEUE_T *queue;               /**< queue for empty buffers sent to the port */
    MMAL_CLOCK_T *clock;               /**< clock module for scheduling requests */
    MMAL_BOOL_T is_reference;          /**< TRUE -> clock port is a reference, therefore
                                            will forward time updates */
-} MMAL_PORT_MODULE_T;
+   MMAL_BOOL_T buffer_info_reporting; /**< controls buffer info reporting */
+} MMAL_PORT_CLOCK_T;
 
 /*****************************************************************************
  * Private functions
@@ -95,58 +96,86 @@ static void mmal_port_clock_request_cb(MMAL_CLOCK_T* clock, int64_t media_time,
 /* Process buffers received from other clock ports */
 static MMAL_STATUS_T mmal_port_clock_process_buffer(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
+   MMAL_PORT_CLOCK_T *priv_clock = port->priv->clock;
    MMAL_STATUS_T status = MMAL_SUCCESS;
-   MMAL_CLOCK_PAYLOAD_T payload;
+   MMAL_CLOCK_EVENT_T event = MMAL_CLOCK_EVENT_INIT(MMAL_CLOCK_EVENT_INVALID);
 
-   if (buffer->length != sizeof(MMAL_CLOCK_PAYLOAD_T))
+   if (buffer->length != sizeof(MMAL_CLOCK_EVENT_T))
    {
-      LOG_ERROR("invalid buffer length %d", buffer->length);
+      LOG_ERROR("invalid buffer length %d expected %d",
+                buffer->length, sizeof(MMAL_CLOCK_EVENT_T));
       return MMAL_EINVAL;
    }
 
    mmal_buffer_header_mem_lock(buffer);
-   memcpy(&payload, buffer->data, sizeof(MMAL_CLOCK_PAYLOAD_T));
+   memcpy(&event, buffer->data, sizeof(MMAL_CLOCK_EVENT_T));
    mmal_buffer_header_mem_unlock(buffer);
 
-   if (payload.magic != MMAL_CLOCK_PAYLOAD_MAGIC)
+   if (event.magic != MMAL_CLOCK_EVENT_MAGIC)
    {
-      LOG_ERROR("buffer corrupt (magic %4.4s)", (char*)&payload.magic);
+      LOG_ERROR("buffer corrupt (magic %4.4s)", (char*)&event.magic);
+      buffer->length = 0;
+      mmal_port_buffer_header_callback(port, buffer);
       return MMAL_EINVAL;
    }
 
-   LOG_TRACE("port %s length %d id %4.4s time %"PRIi64,
-         port->name, buffer->length, (char*)&payload.id, payload.time);
+   LOG_TRACE("port %s id %4.4s", port->name, (char*)&event.id);
 
-   switch (payload.id)
+   switch (event.id)
    {
-   case MMAL_CLOCK_PAYLOAD_TIME:
-      mmal_clock_media_time_set(port->priv->module->clock, payload.time);
+   case MMAL_CLOCK_EVENT_ACTIVE:
+      status = mmal_clock_active_set(priv_clock->clock, event.data.enable);
+      break;
+   case MMAL_CLOCK_EVENT_TIME:
+      status = mmal_clock_media_time_set(priv_clock->clock, event.data.media_time);
+      break;
+   case MMAL_CLOCK_EVENT_SCALE:
+      status = mmal_clock_scale_set(priv_clock->clock, event.data.scale);
+      break;
+   case MMAL_CLOCK_EVENT_UPDATE_THRESHOLD:
+      status = mmal_clock_update_threshold_set(priv_clock->clock, &event.data.update_threshold);
       break;
-   case MMAL_CLOCK_PAYLOAD_SCALE:
-      mmal_clock_scale_set(port->priv->module->clock, payload.data.scale);
+   case MMAL_CLOCK_EVENT_DISCONT_THRESHOLD:
+      status = mmal_clock_discont_threshold_set(priv_clock->clock, &event.data.discont_threshold);
+      break;
+   case MMAL_CLOCK_EVENT_REQUEST_THRESHOLD:
+      status = mmal_clock_request_threshold_set(priv_clock->clock, &event.data.request_threshold);
+      break;
+   case MMAL_CLOCK_EVENT_INPUT_BUFFER_INFO:
+   case MMAL_CLOCK_EVENT_OUTPUT_BUFFER_INFO:
+      /* nothing to do - just forward to the client */
       break;
    default:
-      LOG_ERROR("invalid id %4.4s", (char*)&payload.id);
+      LOG_ERROR("invalid event %4.4s", (char*)&event.id);
       status = MMAL_EINVAL;
       break;
    }
 
-   /* Finished with the buffer, so return it */
-   buffer->length = 0;
-   mmal_port_buffer_header_callback(port, buffer);
+   if (priv_clock->event_cb && status == MMAL_SUCCESS)
+   {
+      /* Notify the component, but don't return the buffer */
+      event.buffer = buffer;
+      priv_clock->event_cb(port, &event);
+   }
+   else
+   {
+      /* Finished with the buffer, so return it */
+      buffer->length = 0;
+      mmal_port_buffer_header_callback(port, buffer);
+   }
 
    return status;
 }
 
 static MMAL_STATUS_T mmal_port_clock_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
-   MMAL_PORT_MODULE_T *module = port->priv->module;
+   MMAL_PORT_CLOCK_T *priv_clock = port->priv->clock;
 
    if (buffer->length)
       return mmal_port_clock_process_buffer(port, buffer);
 
    /* Queue empty buffers to be used later when forwarding clock updates */
-   mmal_queue_put(module->queue, buffer);
+   mmal_queue_put(priv_clock->queue, buffer);
 
    return MMAL_SUCCESS;
 }
@@ -156,11 +185,11 @@ static MMAL_STATUS_T mmal_port_clock_flush(MMAL_PORT_T *port)
    MMAL_BUFFER_HEADER_T *buffer;
 
    /* Flush empty buffers */
-   buffer = mmal_queue_get(port->priv->module->queue);
+   buffer = mmal_queue_get(port->priv->clock->queue);
    while (buffer)
    {
       mmal_port_buffer_header_callback(port, buffer);
-      buffer = mmal_queue_get(port->priv->module->queue);
+      buffer = mmal_queue_get(port->priv->clock->queue);
    }
 
    return MMAL_SUCCESS;
@@ -169,26 +198,23 @@ static MMAL_STATUS_T mmal_port_clock_flush(MMAL_PORT_T *port)
 static MMAL_STATUS_T mmal_port_clock_parameter_set(MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param)
 {
    MMAL_STATUS_T status = MMAL_SUCCESS;
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_CLOCK_PAYLOAD_T event;
+   MMAL_CLOCK_EVENT_T event = MMAL_CLOCK_EVENT_INIT(MMAL_CLOCK_EVENT_INVALID);
 
    switch (param->id)
    {
       case MMAL_PARAMETER_CLOCK_REFERENCE:
       {
          const MMAL_PARAMETER_BOOLEAN_T *p = (const MMAL_PARAMETER_BOOLEAN_T*)param;
-         module->is_reference = p->enable;
-         event.id = MMAL_CLOCK_PAYLOAD_REFERENCE;
-         event.time = mmal_clock_media_time_get(module->clock);
+         status = mmal_port_clock_reference_set(port, p->enable);
+         event.id = MMAL_CLOCK_EVENT_REFERENCE;
          event.data.enable = p->enable;
       }
       break;
       case MMAL_PARAMETER_CLOCK_ACTIVE:
       {
          const MMAL_PARAMETER_BOOLEAN_T *p = (const MMAL_PARAMETER_BOOLEAN_T*)param;
-         status = mmal_clock_active_set(module->clock, p->enable);
-         event.id = MMAL_CLOCK_PAYLOAD_ACTIVE;
-         event.time = mmal_clock_media_time_get(module->clock);
+         status = mmal_port_clock_active_set(port, p->enable);
+         event.id = MMAL_CLOCK_EVENT_ACTIVE;
          event.data.enable = p->enable;
       }
       break;
@@ -196,8 +222,7 @@ static MMAL_STATUS_T mmal_port_clock_parameter_set(MMAL_PORT_T *port, const MMAL
       {
          const MMAL_PARAMETER_RATIONAL_T *p = (const MMAL_PARAMETER_RATIONAL_T*)param;
          status = mmal_port_clock_scale_set(port, p->value);
-         event.id = MMAL_CLOCK_PAYLOAD_SCALE;
-         event.time = mmal_clock_media_time_get(module->clock);
+         event.id = MMAL_CLOCK_EVENT_SCALE;
          event.data.scale = p->value;
       }
       break;
@@ -205,106 +230,113 @@ static MMAL_STATUS_T mmal_port_clock_parameter_set(MMAL_PORT_T *port, const MMAL
       {
          const MMAL_PARAMETER_INT64_T *p = (const MMAL_PARAMETER_INT64_T*)param;
          status = mmal_port_clock_media_time_set(port, p->value);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_TIME_OFFSET:
-      {
-         const MMAL_PARAMETER_INT64_T *p = (const MMAL_PARAMETER_INT64_T*)param;
-         status = mmal_port_clock_media_time_offset_set(port, p->value);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
+         event.id = MMAL_CLOCK_EVENT_TIME;
+         event.data.media_time = p->value;
       }
       break;
       case MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD:
       {
-         const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *)param;
-         status = mmal_clock_update_threshold_set(module->clock, p);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
+         const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *p = (const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *)param;
+         status = mmal_port_clock_update_threshold_set(port, &p->value);
+         event.id = MMAL_CLOCK_EVENT_UPDATE_THRESHOLD;
+         event.data.update_threshold = p->value;
       }
       break;
       case MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD:
       {
-         const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *)param;
-         status = mmal_clock_discont_threshold_set(module->clock, p);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
+         const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *p = (const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *)param;
+         status = mmal_port_clock_discont_threshold_set(port, &p->value);
+         event.id = MMAL_CLOCK_EVENT_DISCONT_THRESHOLD;
+         event.data.discont_threshold = p->value;
       }
       break;
       case MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD:
       {
-         const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *)param;
-         status = mmal_clock_request_threshold_set(module->clock, p);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
+         const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *p = (const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *)param;
+         status = mmal_port_clock_request_threshold_set(port, &p->value);
+         event.id = MMAL_CLOCK_EVENT_REQUEST_THRESHOLD;
+         event.data.request_threshold = p->value;
       }
       break;
+      case MMAL_PARAMETER_CLOCK_ENABLE_BUFFER_INFO:
+      {
+         const MMAL_PARAMETER_BOOLEAN_T *p = (const MMAL_PARAMETER_BOOLEAN_T*)param;
+         port->priv->clock->buffer_info_reporting = p->enable;
+         return MMAL_SUCCESS;
+      }
       default:
+         LOG_ERROR("unsupported clock parameter 0x%x", param->id);
          return MMAL_ENOSYS;
    }
 
    /* Notify the component */
-   if (module->event_cb && status == MMAL_SUCCESS && event.id != MMAL_CLOCK_PAYLOAD_INVALID)
-      module->event_cb(port, &event);
+   if (port->priv->clock->event_cb && status == MMAL_SUCCESS)
+      port->priv->clock->event_cb(port, &event);
 
    return status;
 }
 
 static MMAL_STATUS_T mmal_port_clock_parameter_get(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param)
 {
-   MMAL_PORT_MODULE_T *module = port->priv->module;
+   MMAL_PORT_CLOCK_T *priv_clock = port->priv->clock;
+   MMAL_STATUS_T status = MMAL_SUCCESS;
 
    switch (param->id)
    {
       case MMAL_PARAMETER_CLOCK_REFERENCE:
       {
          MMAL_PARAMETER_BOOLEAN_T *p = (MMAL_PARAMETER_BOOLEAN_T*)param;
-         p->enable = module->is_reference;
+         p->enable = priv_clock->is_reference;
       }
       break;
       case MMAL_PARAMETER_CLOCK_ACTIVE:
       {
          MMAL_PARAMETER_BOOLEAN_T *p = (MMAL_PARAMETER_BOOLEAN_T*)param;
-         p->enable = mmal_clock_is_active(module->clock);
+         p->enable = mmal_clock_is_active(priv_clock->clock);
       }
       break;
       case MMAL_PARAMETER_CLOCK_SCALE:
       {
          MMAL_PARAMETER_RATIONAL_T *p = (MMAL_PARAMETER_RATIONAL_T*)param;
-         p->value = mmal_clock_scale_get(module->clock);
+         p->value = mmal_clock_scale_get(priv_clock->clock);
       }
       break;
       case MMAL_PARAMETER_CLOCK_TIME:
       {
          MMAL_PARAMETER_INT64_T *p = (MMAL_PARAMETER_INT64_T*)param;
-         p->value = mmal_clock_media_time_get(module->clock);
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_TIME_OFFSET:
-      {
-         MMAL_PARAMETER_INT64_T *p = (MMAL_PARAMETER_INT64_T*)param;
-         p->value = mmal_clock_media_time_offset_get(module->clock);
+         p->value = mmal_clock_media_time_get(priv_clock->clock);
       }
       break;
       case MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD:
       {
          MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *)param;
-         mmal_clock_update_threshold_get(module->clock, p);
+         status = mmal_clock_update_threshold_get(priv_clock->clock, &p->value);
       }
       break;
       case MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD:
       {
          MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *)param;
-         mmal_clock_discont_threshold_get(module->clock, p);
+         status = mmal_clock_discont_threshold_get(priv_clock->clock, &p->value);
       }
       break;
       case MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD:
       {
          MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *)param;
-         mmal_clock_request_threshold_get(module->clock, p);
+         status = mmal_clock_request_threshold_get(priv_clock->clock, &p->value);
+      }
+      break;
+      case MMAL_PARAMETER_CLOCK_ENABLE_BUFFER_INFO:
+      {
+         MMAL_PARAMETER_BOOLEAN_T *p = (MMAL_PARAMETER_BOOLEAN_T*)param;
+         p->enable = priv_clock->buffer_info_reporting;
       }
       break;
       default:
+         LOG_ERROR("unsupported clock parameter 0x%x", param->id);
          return MMAL_ENOSYS;
    }
-   return MMAL_SUCCESS;
+
+   return status;
 }
 
 static MMAL_STATUS_T mmal_port_clock_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
@@ -316,10 +348,10 @@ static MMAL_STATUS_T mmal_port_clock_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T
 
 static MMAL_STATUS_T mmal_port_clock_disable(MMAL_PORT_T *port)
 {
-   MMAL_PORT_MODULE_T *module = port->priv->module;
+   MMAL_PORT_CLOCK_T *priv_clock = port->priv->clock;
 
-   if (mmal_clock_is_active(module->clock))
-      mmal_clock_active_set(module->clock, MMAL_FALSE);
+   if (mmal_clock_is_active(priv_clock->clock))
+      mmal_clock_active_set(priv_clock->clock, MMAL_FALSE);
 
    mmal_port_clock_flush(port);
 
@@ -339,16 +371,16 @@ static MMAL_STATUS_T mmal_port_clock_connect(MMAL_PORT_T *port, MMAL_PORT_T *oth
    return MMAL_ENOSYS;
 }
 
-/* Send a payload buffer to a connected port/client */
-static MMAL_STATUS_T mmal_port_clock_forward_payload(MMAL_PORT_T *port, const MMAL_CLOCK_PAYLOAD_T *payload)
+/* Send an event buffer to a connected port */
+static MMAL_STATUS_T mmal_port_clock_forward_event(MMAL_PORT_T *port, const MMAL_CLOCK_EVENT_T *event)
 {
    MMAL_STATUS_T status;
    MMAL_BUFFER_HEADER_T *buffer;
 
-   buffer = mmal_queue_get(port->priv->module->queue);
+   buffer = mmal_queue_get(port->priv->clock->queue);
    if (!buffer)
    {
-      LOG_ERROR("no free buffers available");
+      LOG_INFO("%s: no free event buffers available for event %4.4s", port->name, (const char*)&event->id);
       return MMAL_ENOSPC;
    }
 
@@ -356,11 +388,11 @@ static MMAL_STATUS_T mmal_port_clock_forward_payload(MMAL_PORT_T *port, const MM
    if (status != MMAL_SUCCESS)
    {
       LOG_ERROR("failed to lock buffer %s", mmal_status_to_string(status));
-      mmal_queue_put_back(port->priv->module->queue, buffer);
+      mmal_queue_put_back(port->priv->clock->queue, buffer);
       goto end;
    }
-   buffer->length = sizeof(MMAL_CLOCK_PAYLOAD_T);
-   memcpy(buffer->data, payload, buffer->length);
+   buffer->length = sizeof(MMAL_CLOCK_EVENT_T);
+   memcpy(buffer->data, event, buffer->length);
    mmal_buffer_header_mem_unlock(buffer);
 
    mmal_port_buffer_header_callback(port, buffer);
@@ -369,54 +401,132 @@ end:
    return status;
 }
 
-/* Send a clock time update to a connected port/client */
-static MMAL_STATUS_T mmal_port_clock_forward_media_time(MMAL_PORT_T *port, int64_t media_time)
+/* Send a clock active state to a connected port */
+static MMAL_STATUS_T mmal_port_clock_forward_active_state(MMAL_PORT_T *port, MMAL_BOOL_T active)
 {
-   MMAL_CLOCK_PAYLOAD_T payload;
+   MMAL_CLOCK_EVENT_T event;
 
-   payload.id = MMAL_CLOCK_PAYLOAD_TIME;
-   payload.magic = MMAL_CLOCK_PAYLOAD_MAGIC;
-   payload.time = media_time;
+   event.id = MMAL_CLOCK_EVENT_ACTIVE;
+   event.magic = MMAL_CLOCK_EVENT_MAGIC;
+   event.data.enable = active;
 
-   return mmal_port_clock_forward_payload(port, &payload);
+   return mmal_port_clock_forward_event(port, &event);
 }
 
-/* Send a clock scale update to a connected port/client */
+/* Send a clock scale update to a connected port */
 static MMAL_STATUS_T mmal_port_clock_forward_scale(MMAL_PORT_T *port, MMAL_RATIONAL_T scale)
 {
-   MMAL_CLOCK_PAYLOAD_T payload;
+   MMAL_CLOCK_EVENT_T event;
+
+   event.id = MMAL_CLOCK_EVENT_SCALE;
+   event.magic = MMAL_CLOCK_EVENT_MAGIC;
+   event.data.scale = scale;
+
+   return mmal_port_clock_forward_event(port, &event);
+}
+
+/* Send a clock time update to a connected port */
+static MMAL_STATUS_T mmal_port_clock_forward_media_time(MMAL_PORT_T *port, int64_t media_time)
+{
+   MMAL_CLOCK_EVENT_T event;
+
+   event.id = MMAL_CLOCK_EVENT_TIME;
+   event.magic = MMAL_CLOCK_EVENT_MAGIC;
+   event.data.media_time = media_time;
+
+   return mmal_port_clock_forward_event(port, &event);
+}
+
+/* Send a clock update threshold to a connected port */
+static MMAL_STATUS_T mmal_port_clock_forward_update_threshold(MMAL_PORT_T *port,
+      const MMAL_CLOCK_UPDATE_THRESHOLD_T *threshold)
+{
+   MMAL_CLOCK_EVENT_T event;
 
-   payload.id = MMAL_CLOCK_PAYLOAD_SCALE;
-   payload.magic = MMAL_CLOCK_PAYLOAD_MAGIC;
-   payload.time = mmal_clock_media_time_get(port->priv->module->clock);
-   payload.data.scale = scale;
+   event.id = MMAL_CLOCK_EVENT_UPDATE_THRESHOLD;
+   event.magic = MMAL_CLOCK_EVENT_MAGIC;
+   event.data.update_threshold = *threshold;
 
-   return mmal_port_clock_forward_payload(port, &payload);
+   return mmal_port_clock_forward_event(port, &event);
+}
+
+/* Send a clock discontinuity threshold to a connected port */
+static MMAL_STATUS_T mmal_port_clock_forward_discont_threshold(MMAL_PORT_T *port,
+      const MMAL_CLOCK_DISCONT_THRESHOLD_T *threshold)
+{
+   MMAL_CLOCK_EVENT_T event;
+
+   event.id = MMAL_CLOCK_EVENT_DISCONT_THRESHOLD;
+   event.magic = MMAL_CLOCK_EVENT_MAGIC;
+   event.data.discont_threshold = *threshold;
+
+   return mmal_port_clock_forward_event(port, &event);
+}
+
+/* Send a clock request threshold to a connected port */
+static MMAL_STATUS_T mmal_port_clock_forward_request_threshold(MMAL_PORT_T *port,
+      const MMAL_CLOCK_REQUEST_THRESHOLD_T *threshold)
+{
+   MMAL_CLOCK_EVENT_T event;
+
+   event.id = MMAL_CLOCK_EVENT_REQUEST_THRESHOLD;
+   event.magic = MMAL_CLOCK_EVENT_MAGIC;
+   event.data.request_threshold = *threshold;
+
+   return mmal_port_clock_forward_event(port, &event);
+}
+
+/* Send information regarding an input buffer to connected port */
+static MMAL_STATUS_T mmal_port_clock_forward_input_buffer_info(MMAL_PORT_T *port, const MMAL_CLOCK_BUFFER_INFO_T *info)
+{
+   MMAL_CLOCK_EVENT_T event;
+
+   event.id = MMAL_CLOCK_EVENT_INPUT_BUFFER_INFO;
+   event.magic = MMAL_CLOCK_EVENT_MAGIC;
+   event.data.buffer = *info;
+
+   return mmal_port_clock_forward_event(port, &event);
+}
+
+/* Send information regarding an output buffer to connected port */
+static MMAL_STATUS_T mmal_port_clock_forward_output_buffer_info(MMAL_PORT_T *port, const MMAL_CLOCK_BUFFER_INFO_T *info)
+{
+   MMAL_CLOCK_EVENT_T event;
+
+   event.id = MMAL_CLOCK_EVENT_OUTPUT_BUFFER_INFO;
+   event.magic = MMAL_CLOCK_EVENT_MAGIC;
+   event.data.buffer = *info;
+
+   return mmal_port_clock_forward_event(port, &event);
 }
 
 /* Initialise all callbacks and setup internal resources */
-static MMAL_STATUS_T mmal_port_clock_setup(MMAL_PORT_T *port, MMAL_PORT_CLOCK_EVENT_CB event_cb)
+static MMAL_STATUS_T mmal_port_clock_setup(MMAL_PORT_T *port, unsigned int extra_size,
+                                           MMAL_PORT_CLOCK_EVENT_CB event_cb)
 {
    MMAL_STATUS_T status;
 
-   status = mmal_clock_create(&port->priv->module->clock);
+   port->priv->clock = (MMAL_PORT_CLOCK_T*)((char*)(port->priv->module) + extra_size);
+
+   status = mmal_clock_create(&port->priv->clock->clock);
    if (status != MMAL_SUCCESS)
    {
-      LOG_ERROR("failed to create clock module on port %s (%s)", port->name, mmal_status_to_string(status));
+      LOG_ERROR("failed to create clock module on port %s (%s)",
+                port->name, mmal_status_to_string(status));
       return status;
    }
-   port->priv->module->clock->user_data = port;
+   port->priv->clock->clock->user_data = port;
 
-   port->buffer_size = sizeof(MMAL_CLOCK_PAYLOAD_T);
-   port->buffer_size_min = sizeof(MMAL_CLOCK_PAYLOAD_T);
+   port->buffer_size = sizeof(MMAL_CLOCK_EVENT_T);
+   port->buffer_size_min = sizeof(MMAL_CLOCK_EVENT_T);
    port->buffer_num_min = MMAL_PORT_CLOCK_BUFFERS_MIN;
    port->buffer_num_recommended = MMAL_PORT_CLOCK_BUFFERS_MIN;
 
-   port->priv->module->event_cb = event_cb;
-   port->priv->module->queue = mmal_queue_create();
-   if (!port->priv->module->queue)
+   port->priv->clock->event_cb = event_cb;
+   port->priv->clock->queue = mmal_queue_create();
+   if (!port->priv->clock->queue)
    {
-      mmal_clock_destroy(port->priv->module->clock);
+      mmal_clock_destroy(port->priv->clock->clock);
       return MMAL_ENOMEM;
    }
 
@@ -442,23 +552,25 @@ static void mmal_port_clock_teardown(MMAL_PORT_T *port)
 {
    if (!port)
       return;
-   mmal_queue_destroy(port->priv->module->queue);
-   mmal_clock_destroy(port->priv->module->clock);
+   mmal_queue_destroy(port->priv->clock->queue);
+   mmal_clock_destroy(port->priv->clock->clock);
 }
 
 /*****************************************************************************
  * Public functions
  *****************************************************************************/
 /* Allocate a clock port */
-MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, MMAL_PORT_CLOCK_EVENT_CB event_cb)
+MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, unsigned int extra_size,
+                                   MMAL_PORT_CLOCK_EVENT_CB event_cb)
 {
    MMAL_PORT_T *port;
 
-   port = mmal_port_alloc(component, MMAL_PORT_TYPE_CLOCK, sizeof(MMAL_PORT_MODULE_T));
+   port = mmal_port_alloc(component, MMAL_PORT_TYPE_CLOCK,
+                          extra_size + sizeof(MMAL_PORT_CLOCK_T));
    if (!port)
       return NULL;
 
-   if (mmal_port_clock_setup(port, event_cb) != MMAL_SUCCESS)
+   if (mmal_port_clock_setup(port, extra_size, event_cb) != MMAL_SUCCESS)
    {
       mmal_port_free(port);
       return NULL;
@@ -475,18 +587,20 @@ void mmal_port_clock_free(MMAL_PORT_T *port)
 }
 
 /* Allocate an array of clock ports */
-MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num, MMAL_PORT_CLOCK_EVENT_CB event_cb)
+MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num,
+                                     unsigned int extra_size, MMAL_PORT_CLOCK_EVENT_CB event_cb)
 {
    unsigned int i;
    MMAL_PORT_T **ports;
 
-   ports = mmal_ports_alloc(component, ports_num, MMAL_PORT_TYPE_CLOCK, sizeof(MMAL_PORT_MODULE_T));
+   ports = mmal_ports_alloc(component, ports_num, MMAL_PORT_TYPE_CLOCK,
+                            extra_size + sizeof(MMAL_PORT_CLOCK_T));
    if (!ports)
       return NULL;
 
    for (i = 0; i < ports_num; i++)
    {
-      if (mmal_port_clock_setup(ports[i], event_cb) != MMAL_SUCCESS)
+      if (mmal_port_clock_setup(ports[i], extra_size, event_cb) != MMAL_SUCCESS)
          break;
    }
 
@@ -512,86 +626,178 @@ void mmal_ports_clock_free(MMAL_PORT_T **ports, unsigned int ports_num)
 }
 
 /* Register a callback request */
-MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time, int64_t offset,
+MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time,
       MMAL_PORT_CLOCK_REQUEST_CB cb, void *cb_data)
 {
-   return mmal_clock_request_add(port->priv->module->clock, media_time, offset,
+   return mmal_clock_request_add(port->priv->clock->clock, media_time,
                                  mmal_port_clock_request_cb, cb_data, (MMAL_CLOCK_VOID_FP)cb);
 }
 
 /* Flush all pending clock requests */
 MMAL_STATUS_T mmal_port_clock_request_flush(MMAL_PORT_T *port)
 {
-   return mmal_clock_request_flush(port->priv->module->clock);
+   return mmal_clock_request_flush(port->priv->clock->clock);
+}
+
+/* Set the clock port's reference state */
+MMAL_STATUS_T mmal_port_clock_reference_set(MMAL_PORT_T *port, MMAL_BOOL_T reference)
+{
+   port->priv->clock->is_reference = reference;
+   return MMAL_SUCCESS;
+}
+
+/* Get the clock port's reference state */
+MMAL_BOOL_T mmal_port_clock_reference_get(MMAL_PORT_T *port)
+{
+   return port->priv->clock->is_reference;
 }
 
-/* Set the media-time on the clock port */
+/* Set the clock port's active state */
+MMAL_STATUS_T mmal_port_clock_active_set(MMAL_PORT_T *port, MMAL_BOOL_T active)
+{
+   MMAL_STATUS_T status;
+
+   status = mmal_clock_active_set(port->priv->clock->clock, active);
+   if (status != MMAL_SUCCESS)
+      return status;
+
+   if (port->priv->clock->is_reference)
+      status = mmal_port_clock_forward_active_state(port, active);
+
+   return status;
+}
+
+/* Get the clock port's active state */
+MMAL_BOOL_T mmal_port_clock_active_get(MMAL_PORT_T *port)
+{
+   return mmal_clock_is_active(port->priv->clock->clock);
+}
+
+/* Set the clock port's scale */
+MMAL_STATUS_T mmal_port_clock_scale_set(MMAL_PORT_T *port, MMAL_RATIONAL_T scale)
+{
+   MMAL_STATUS_T status;
+
+   status = mmal_clock_scale_set(port->priv->clock->clock, scale);
+   if (status != MMAL_SUCCESS)
+      return status;
+
+   if (port->priv->clock->is_reference)
+      status = mmal_port_clock_forward_scale(port, scale);
+
+   return status;
+}
+
+/* Get the clock port's scale */
+MMAL_RATIONAL_T mmal_port_clock_scale_get(MMAL_PORT_T *port)
+{
+   return mmal_clock_scale_get(port->priv->clock->clock);
+}
+
+/* Set the clock port's media-time */
 MMAL_STATUS_T mmal_port_clock_media_time_set(MMAL_PORT_T *port, int64_t media_time)
 {
    MMAL_STATUS_T status;
 
-   status = mmal_clock_media_time_set(port->priv->module->clock, media_time);
+   status = mmal_clock_media_time_set(port->priv->clock->clock, media_time);
    if (status != MMAL_SUCCESS)
    {
-      LOG_DEBUG("clock update ignored");
+      LOG_DEBUG("clock media-time update ignored");
       return status;
    }
 
-   /* Only forward time updates if this port is set as a reference clock port */
-   if (port->priv->module->is_reference)
-      mmal_port_clock_forward_media_time(port, mmal_clock_media_time_get(port->priv->module->clock));
+   if (port->priv->clock->is_reference)
+      status = mmal_port_clock_forward_media_time(port, media_time);
 
    return status;
 }
 
-/* Set the media-time offset on the clock port */
-MMAL_STATUS_T mmal_port_clock_media_time_offset_set(MMAL_PORT_T *port, int64_t offset)
+/* Get the clock port's media-time */
+int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port)
+{
+   return mmal_clock_media_time_get(port->priv->clock->clock);
+}
+
+/* Set the clock port's update threshold */
+MMAL_STATUS_T mmal_port_clock_update_threshold_set(MMAL_PORT_T *port,
+                                                   const MMAL_CLOCK_UPDATE_THRESHOLD_T *threshold)
 {
    MMAL_STATUS_T status;
 
-   status = mmal_clock_media_time_offset_set(port->priv->module->clock, offset);
+   status = mmal_clock_update_threshold_set(port->priv->clock->clock, threshold);
+   if (status != MMAL_SUCCESS)
+      return status;
 
-   /* The media-time has effectively changed, so need to inform connected clock ports */
-   if (port->priv->module->is_reference)
-      mmal_port_clock_forward_media_time(port, mmal_clock_media_time_get(port->priv->module->clock));
+   if (port->priv->clock->is_reference)
+      status = mmal_port_clock_forward_update_threshold(port, threshold);
 
    return status;
 }
 
-/* Return the current media-time */
-int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port)
+/* Get the clock port's update threshold */
+MMAL_STATUS_T mmal_port_clock_update_threshold_get(MMAL_PORT_T *port,
+                                          MMAL_CLOCK_UPDATE_THRESHOLD_T *threshold)
+{
+   return mmal_clock_update_threshold_get(port->priv->clock->clock, threshold);
+}
+
+/* Set the clock port's discontinuity threshold */
+MMAL_STATUS_T mmal_port_clock_discont_threshold_set(MMAL_PORT_T *port,
+                                                    const MMAL_CLOCK_DISCONT_THRESHOLD_T *threshold)
 {
-   return mmal_clock_media_time_get(port->priv->module->clock);
+   MMAL_STATUS_T status;
+
+   status = mmal_clock_discont_threshold_set(port->priv->clock->clock, threshold);
+   if (status != MMAL_SUCCESS)
+      return status;
+
+   if (port->priv->clock->is_reference)
+      status = mmal_port_clock_forward_discont_threshold(port, threshold);
+
+   return status;
 }
 
-/* Return the media-time offset */
-int64_t mmal_port_clock_media_time_offset_get(MMAL_PORT_T *port)
+/* Get the clock port's discontinuity threshold */
+MMAL_STATUS_T mmal_port_clock_discont_threshold_get(MMAL_PORT_T *port,
+                                           MMAL_CLOCK_DISCONT_THRESHOLD_T *threshold)
 {
-   return mmal_clock_media_time_offset_get(port->priv->module->clock);
+   return mmal_clock_discont_threshold_get(port->priv->clock->clock, threshold);
 }
 
-/* Set the clock scale factor */
-MMAL_STATUS_T mmal_port_clock_scale_set(MMAL_PORT_T *port, MMAL_RATIONAL_T scale)
+/* Set the clock port's request threshold */
+MMAL_STATUS_T mmal_port_clock_request_threshold_set(MMAL_PORT_T *port,
+                                                    const MMAL_CLOCK_REQUEST_THRESHOLD_T *threshold)
 {
    MMAL_STATUS_T status;
 
-   status = mmal_clock_scale_set(port->priv->module->clock, scale);
+   status = mmal_clock_request_threshold_set(port->priv->clock->clock, threshold);
+   if (status != MMAL_SUCCESS)
+      return status;
 
-   if (port->priv->module->is_reference)
-      mmal_port_clock_forward_scale(port, scale);
+   if (port->priv->clock->is_reference)
+      status = mmal_port_clock_forward_request_threshold(port, threshold);
 
    return status;
 }
 
-/* Return the clock scale factor */
-MMAL_RATIONAL_T mmal_port_clock_scale_get(MMAL_PORT_T *port)
+/* Get the clock port's request threshold */
+MMAL_STATUS_T mmal_port_clock_request_threshold_get(MMAL_PORT_T *port,
+                                           MMAL_CLOCK_REQUEST_THRESHOLD_T *threshold)
+{
+   return mmal_clock_request_threshold_get(port->priv->clock->clock, threshold);
+}
+
+/* Provide input buffer information */
+void mmal_port_clock_input_buffer_info(MMAL_PORT_T *port, const MMAL_CLOCK_BUFFER_INFO_T *info)
 {
-   return mmal_clock_scale_get(port->priv->module->clock);
+   if (port->priv->clock->buffer_info_reporting)
+      mmal_port_clock_forward_input_buffer_info(port, info);
 }
 
-/* Return TRUE if clock is running (media-time is advancing) */
-MMAL_BOOL_T mmal_port_clock_is_active(MMAL_PORT_T *port)
+/* Provide output buffer information */
+void mmal_port_clock_output_buffer_info(MMAL_PORT_T *port, const MMAL_CLOCK_BUFFER_INFO_T *info)
 {
-   return mmal_clock_is_active(port->priv->module->clock);
+   if (port->priv->clock->buffer_info_reporting)
+      mmal_port_clock_forward_output_buffer_info(port, info);
 }
 
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_private.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_private.h
index 61b1df3..1e538c5 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_private.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_private.h
@@ -30,6 +30,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "interface/mmal/mmal.h"
 #include "interface/mmal/mmal_clock.h"
+#include "interface/mmal/core/mmal_events_private.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /** Definition of a port. */
 typedef struct MMAL_PORT_PRIVATE_T
@@ -38,6 +43,8 @@ typedef struct MMAL_PORT_PRIVATE_T
    struct MMAL_PORT_PRIVATE_CORE_T *core;
    /** Pointer to the private data of the module in use */
    struct MMAL_PORT_MODULE_T *module;
+   /** Pointer to the private data used by clock ports */
+   struct MMAL_PORT_CLOCK_T *clock;
 
    MMAL_STATUS_T (*pf_set_format)(MMAL_PORT_T *port);
    MMAL_STATUS_T (*pf_enable)(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T);
@@ -81,6 +88,9 @@ MMAL_STATUS_T mmal_port_release(MMAL_PORT_T *port);
 /** Pause processing on a port */
 MMAL_STATUS_T mmal_port_pause(MMAL_PORT_T *port, MMAL_BOOL_T pause);
 
+/** Returns whether a port is connected or not */
+MMAL_BOOL_T mmal_port_is_connected(MMAL_PORT_T *port);
+
 /*****************************************************************************
  * Clock Port API
  *****************************************************************************/
@@ -90,16 +100,18 @@ MMAL_STATUS_T mmal_port_pause(MMAL_PORT_T *port, MMAL_BOOL_T pause);
  * @param port       The clock port where the event occurred
  * @param event      The event that has occurred
  */
-typedef void (*MMAL_PORT_CLOCK_EVENT_CB)(MMAL_PORT_T *port, const MMAL_CLOCK_PAYLOAD_T *event);
+typedef void (*MMAL_PORT_CLOCK_EVENT_CB)(MMAL_PORT_T *port, const MMAL_CLOCK_EVENT_T *event);
 
 /** Allocate a clock port.
  *
  * @param component  The component requesting the alloc
+ * @param extra_size Size of the port module
  * @param event_cb   Clock event callback
  *
  * @return Pointer to new clock port or NULL on failure.
  */
-MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, MMAL_PORT_CLOCK_EVENT_CB event_cb);
+MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, unsigned int extra_size,
+                                   MMAL_PORT_CLOCK_EVENT_CB event_cb);
 
 /** Free a clock port.
  *
@@ -111,11 +123,13 @@ void mmal_port_clock_free(MMAL_PORT_T *port);
  *
  * @param component  The component requesting the alloc
  * @param ports_num  Number of ports to allocate
+ * @param extra_size Size of the port module
  * @param event_cb   Clock event callback
  *
  * @return Pointer to a new array of clock ports or NULL on failure.
  */
-MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num, MMAL_PORT_CLOCK_EVENT_CB event_cb);
+MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num,
+                                     unsigned int extra_size, MMAL_PORT_CLOCK_EVENT_CB event_cb);
 
 /** Free an array of clock ports.
  *
@@ -138,14 +152,12 @@ typedef void (*MMAL_PORT_CLOCK_REQUEST_CB)(MMAL_PORT_T *port, int64_t media_time
  *
  * @param port       The clock port
  * @param media_time The media-time at which the callback should be invoked (microseconds)
- * @param offset     Time offset (in microseconds) applied to the media-time. This can be used
- *                   to schedule the request slightly in advance of the media-time.
  * @param cb         Callback to invoke
  * @param cb_data    Client-supplied callback data
  *
  * @return MMAL_SUCCESS on success
  */
-MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time, int64_t offset,
+MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time,
                                           MMAL_PORT_CLOCK_REQUEST_CB cb, void *cb_data);
 
 /** Remove all previously registered clock port requests.
@@ -156,64 +168,46 @@ MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time,
  */
 MMAL_STATUS_T mmal_port_clock_request_flush(MMAL_PORT_T *port);
 
-/** Update the clock port's media-time.
- *
- * @param port       The clock port to update
- * @param media_time New media-time to be applied (microseconds)
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_clock_media_time_set(MMAL_PORT_T *port, int64_t media_time);
-
-/** Set an offset for the port's media-time.
- *
- * @param port       The clock port to update
- * @param offset     Media-time offset (microseconds)
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_clock_media_time_offset_set(MMAL_PORT_T *port, int64_t offset);
-
-/** Get the clock port's current media-time.
- * This takes the clock port's scale and media-time offset into account.
- *
- * @param port       The clock port to query
- *
- * @return Current media-time in microseconds
- */
-int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port);
+/** Get/set the clock port's reference state */
+MMAL_STATUS_T mmal_port_clock_reference_set(MMAL_PORT_T *port, MMAL_BOOL_T reference);
+MMAL_BOOL_T mmal_port_clock_reference_get(MMAL_PORT_T *port);
 
-/** Get the clock port's media-time offset.
- *
- * @param port       The clock port to query
- *
- * @return Media-time offset in microseconds
- */
-int64_t mmal_port_clock_media_time_offset_get(MMAL_PORT_T *port);
+/** Get/set the clock port's active state */
+MMAL_STATUS_T mmal_port_clock_active_set(MMAL_PORT_T *port, MMAL_BOOL_T active);
+MMAL_BOOL_T mmal_port_clock_active_get(MMAL_PORT_T *port);
 
-/** Set the clock port's scale.
- *
- * @param port       The clock port
- * @param scale      Scale factor in Q16 format
- *
- * @return MMAL_SUCCESS on success
- */
+/** Get/set the clock port's scale */
 MMAL_STATUS_T mmal_port_clock_scale_set(MMAL_PORT_T *port, MMAL_RATIONAL_T scale);
-
-/** Get the clock port's scale.
- *
- * @param port       The clock port
- *
- * @return Current clock port scale factor
- */
 MMAL_RATIONAL_T mmal_port_clock_scale_get(MMAL_PORT_T *port);
 
-/** Get the clock port's state.
- *
- * @param port       The clock port to query
- *
- * @return TRUE if clock port is active (i.e. local media-time is advancing)
- */
-MMAL_BOOL_T mmal_port_clock_is_active(MMAL_PORT_T *port);
+/** Get/set the clock port's media-time */
+MMAL_STATUS_T mmal_port_clock_media_time_set(MMAL_PORT_T *port, int64_t media_time);
+int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port);
+
+/** Get/set the clock port's update threshold */
+MMAL_STATUS_T mmal_port_clock_update_threshold_set(MMAL_PORT_T *port,
+                                                   const MMAL_CLOCK_UPDATE_THRESHOLD_T *threshold);
+MMAL_STATUS_T mmal_port_clock_update_threshold_get(MMAL_PORT_T *port,
+                                                   MMAL_CLOCK_UPDATE_THRESHOLD_T *threshold);
+
+/** Get/set the clock port's discontinuity threshold */
+MMAL_STATUS_T mmal_port_clock_discont_threshold_set(MMAL_PORT_T *port,
+                                                    const MMAL_CLOCK_DISCONT_THRESHOLD_T *threshold);
+MMAL_STATUS_T mmal_port_clock_discont_threshold_get(MMAL_PORT_T *port,
+                                                    MMAL_CLOCK_DISCONT_THRESHOLD_T *threshold);
+
+/** Get/set the clock port's request threshold */
+MMAL_STATUS_T mmal_port_clock_request_threshold_set(MMAL_PORT_T *port,
+                                                    const MMAL_CLOCK_REQUEST_THRESHOLD_T *threshold);
+MMAL_STATUS_T mmal_port_clock_request_threshold_get(MMAL_PORT_T *port,
+                                                    MMAL_CLOCK_REQUEST_THRESHOLD_T *threshold);
+
+/** Provide information regarding a buffer received on the component's input/output port */
+void mmal_port_clock_input_buffer_info(MMAL_PORT_T *port, const MMAL_CLOCK_BUFFER_INFO_T *info);
+void mmal_port_clock_output_buffer_info(MMAL_PORT_T *port, const MMAL_CLOCK_BUFFER_INFO_T *info);
+
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* MMAL_PORT_PRIVATE_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_queue.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_queue.c
index bffab1c..d58b28a 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_queue.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_queue.c
@@ -38,6 +38,23 @@ struct MMAL_QUEUE_T
    VCOS_SEMAPHORE_T semaphore;
 };
 
+// Only sanity check if asserts are enabled
+#if VCOS_ASSERT_ENABLED
+static void mmal_queue_sanity_check(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer)
+{
+  MMAL_BUFFER_HEADER_T *q;
+  int len = 0;
+  for (q = queue->first; q && len<queue->length; q = q->next)
+  {
+    vcos_assert(buffer != q);
+    len++;
+  }
+  vcos_assert(len == queue->length && !q);
+}
+#else
+#define mmal_queue_sanity_check(q,b)
+#endif
+
 /** Create a QUEUE of MMAL_BUFFER_HEADER_T */
 MMAL_QUEUE_T *mmal_queue_create(void)
 {
@@ -59,22 +76,37 @@ MMAL_QUEUE_T *mmal_queue_create(void)
       return 0;
    }
 
+   /* gratuitous lock for coverity */ vcos_mutex_lock(&queue->lock);
    queue->length = 0;
    queue->first = 0;
    queue->last = &queue->first;
+   mmal_queue_sanity_check(queue, NULL);
+   /* gratuitous unlock for coverity */ vcos_mutex_unlock(&queue->lock);
+
    return queue;
 }
 
 /** Put a MMAL_BUFFER_HEADER_T into a QUEUE */
 void mmal_queue_put(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer)
 {
+   vcos_assert(queue && buffer);
    if(!queue || !buffer) return;
 
-	vcos_mutex_lock(&queue->lock);
+   vcos_mutex_lock(&queue->lock);
+   mmal_queue_sanity_check(queue, buffer);
    queue->length++;
    *queue->last = buffer;
    buffer->next = 0;
    queue->last = &buffer->next;
+   // There is a possible advantage to putting the semaphore_post outside
+   // the lock as that would avoid the case where we set the semaphore, causing
+   // a task switch to a waiting get thread which then blocks because we still
+   // have the lock.  However this allows a race condition if we have (legit) code
+   // of the (simplified) form:
+   // if (mmal_queue_length(q) > 0) b = mmal_queue_get(q);
+   // where the _get should always succeed
+   // This has an easy fix if we have a fn that returns the count in a semaphore
+   // but by not all OSs support that (e.g. Win32)
    vcos_semaphore_post(&queue->semaphore);
    vcos_mutex_unlock(&queue->lock);
 }
@@ -84,7 +116,8 @@ void mmal_queue_put_back(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer)
 {
    if(!queue || !buffer) return;
 
-	vcos_mutex_lock(&queue->lock);
+   vcos_mutex_lock(&queue->lock);
+   mmal_queue_sanity_check(queue, buffer);
    queue->length++;
    buffer->next = queue->first;
    queue->first = buffer;
@@ -93,23 +126,16 @@ void mmal_queue_put_back(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer)
    vcos_mutex_unlock(&queue->lock);
 }
 
-/** Get a MMAL_BUFFER_HEADER_T from a QUEUE. */
-MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue)
-{
-   MMAL_BUFFER_HEADER_T *buffer;
 
-	if(!queue) return 0;
+/** Get a MMAL_BUFFER_HEADER_T from a QUEUE. Semaphore already claimed */
+static MMAL_BUFFER_HEADER_T *mmal_queue_get_core(MMAL_QUEUE_T *queue)
+{
+   MMAL_BUFFER_HEADER_T * buffer;
 
    vcos_mutex_lock(&queue->lock);
+   mmal_queue_sanity_check(queue, NULL);
    buffer = queue->first;
-   if(!buffer)
-   {
-      vcos_mutex_unlock(&queue->lock);
-      return 0;
-   }
-
-   /* coverity[lock] This semaphore isn't being used as a mutex */
-   vcos_semaphore_wait(&queue->semaphore); /* Will always succeed */
+   vcos_assert(buffer != NULL);
 
    queue->first = buffer->next;
    if(!queue->first) queue->last = &queue->first;
@@ -120,14 +146,38 @@ MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue)
    return buffer;
 }
 
+/** Get a MMAL_BUFFER_HEADER_T from a QUEUE. */
+MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue)
+{
+   vcos_assert(queue);
+   if(!queue) return 0;
+
+   if(vcos_semaphore_trywait(&queue->semaphore) != VCOS_SUCCESS)
+       return NULL;
+
+   return mmal_queue_get_core(queue);
+}
+
 /** Wait for a MMAL_BUFFER_HEADER_T from a QUEUE. */
 MMAL_BUFFER_HEADER_T *mmal_queue_wait(MMAL_QUEUE_T *queue)
 {
 	if(!queue) return 0;
 
-	vcos_semaphore_wait(&queue->semaphore);
-   vcos_semaphore_post(&queue->semaphore);
-   return mmal_queue_get(queue);
+   if (vcos_semaphore_wait(&queue->semaphore) != VCOS_SUCCESS)
+       return NULL;
+
+   return mmal_queue_get_core(queue);
+}
+
+MMAL_BUFFER_HEADER_T *mmal_queue_timedwait(MMAL_QUEUE_T *queue, VCOS_UNSIGNED timeout)
+{
+    if (!queue)
+        return NULL;
+
+    if (vcos_semaphore_wait_timeout(&queue->semaphore, timeout) != VCOS_SUCCESS)
+        return NULL;
+
+    return mmal_queue_get_core(queue);
 }
 
 /** Get the number of MMAL_BUFFER_HEADER_T currently in a QUEUE */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal.h
index e613f94..d3dab07 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal.h
@@ -310,7 +310,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * // Data processing loop
   * while (1)
   * {
-  *    MMAL_BUFFER_HEADER_T *header;
+  *    MMAL_BUFFER_HEADER_T *buffer;
   *
   *    // The client needs to implement its own blocking code.
   *    // (e.g. a semaphore which is posted when a buffer header is put in one of the queues)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_buffer.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_buffer.h
index 2d5a972..923000f 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_buffer.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_buffer.h
@@ -128,20 +128,28 @@ typedef struct MMAL_BUFFER_HEADER_T
 #define MMAL_BUFFER_HEADER_FLAG_CORRUPTED              (1<<9)
 /** Signals that a buffer failed to be transmitted */
 #define MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED    (1<<10)
+/** Signals the output buffer won't be used, just update reference frames */
+#define MMAL_BUFFER_HEADER_FLAG_DECODEONLY             (1<<11)
+/** User flags - can be passed in and will get returned */
+#define MMAL_BUFFER_HEADER_FLAG_USER0                  (1<<28)
+#define MMAL_BUFFER_HEADER_FLAG_USER1                  (1<<29)
+#define MMAL_BUFFER_HEADER_FLAG_USER2                  (1<<30)
+#define MMAL_BUFFER_HEADER_FLAG_USER3                  (1<<31)
 /* @} */
 
 /** \name Video buffer header flags
  * \anchor videobufferheaderflags
  * The following flags describe properties of a video buffer header */
+#define MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START (1<<16)
 /* @{ */
 /** Signals an interlaced video frame */
-#define MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED       (1<<0)
+#define MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED       (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START<<0)
 /** Signals that the top field of the current interlaced frame should be displayed first */
-#define MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST  (1<<2)
+#define MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST  (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START<<1)
 /** Signals that the buffer should be displayed on external display if attached. */
-#define MMAL_BUFFER_HEADER_VIDEO_FLAG_DISPLAY_EXTERNAL (1<<3)
+#define MMAL_BUFFER_HEADER_VIDEO_FLAG_DISPLAY_EXTERNAL (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START<<3)
 /** Signals that contents of the buffer requires copy protection. */
-#define MMAL_BUFFER_HEADER_VIDEO_FLAG_PROTECTED        (1<<4)
+#define MMAL_BUFFER_HEADER_VIDEO_FLAG_PROTECTED        (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START<<4)
 /* @} */
 
 /** Acquire a buffer header.
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_encodings.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_encodings.h
index 0e09b57..45589d7 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_encodings.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_encodings.h
@@ -39,6 +39,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /** \name Pre-defined video encodings */
 /* @{ */
 #define MMAL_ENCODING_H264             MMAL_FOURCC('H','2','6','4')
+#define MMAL_ENCODING_MVC              MMAL_FOURCC('M','V','C',' ')
 #define MMAL_ENCODING_H263             MMAL_FOURCC('H','2','6','3')
 #define MMAL_ENCODING_MP4V             MMAL_FOURCC('M','P','4','V')
 #define MMAL_ENCODING_MP2V             MMAL_FOURCC('M','P','2','V')
@@ -52,6 +53,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MMAL_ENCODING_VP6              MMAL_FOURCC('V','P','6',' ')
 #define MMAL_ENCODING_THEORA           MMAL_FOURCC('T','H','E','O')
 #define MMAL_ENCODING_SPARK            MMAL_FOURCC('S','P','R','K')
+#define MMAL_ENCODING_MJPEG            MMAL_FOURCC('M','J','P','G')
 
 #define MMAL_ENCODING_JPEG             MMAL_FOURCC('J','P','E','G')
 #define MMAL_ENCODING_GIF              MMAL_FOURCC('G','I','F',' ')
@@ -72,15 +74,50 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MMAL_ENCODING_NV12             MMAL_FOURCC('N','V','1','2')
 #define MMAL_ENCODING_NV21             MMAL_FOURCC('N','V','2','1')
 #define MMAL_ENCODING_ARGB             MMAL_FOURCC('A','R','G','B')
+#define MMAL_ENCODING_ARGB_SLICE       MMAL_FOURCC('a','r','g','b')
 #define MMAL_ENCODING_RGBA             MMAL_FOURCC('R','G','B','A')
+#define MMAL_ENCODING_RGBA_SLICE       MMAL_FOURCC('r','g','b','a')
 #define MMAL_ENCODING_ABGR             MMAL_FOURCC('A','B','G','R')
+#define MMAL_ENCODING_ABGR_SLICE       MMAL_FOURCC('a','b','g','r')
 #define MMAL_ENCODING_BGRA             MMAL_FOURCC('B','G','R','A')
+#define MMAL_ENCODING_BGRA_SLICE       MMAL_FOURCC('b','g','r','a')
 #define MMAL_ENCODING_RGB16            MMAL_FOURCC('R','G','B','2')
+#define MMAL_ENCODING_RGB16_SLICE      MMAL_FOURCC('r','g','b','2')
 #define MMAL_ENCODING_RGB24            MMAL_FOURCC('R','G','B','3')
+#define MMAL_ENCODING_RGB24_SLICE      MMAL_FOURCC('r','g','b','3')
 #define MMAL_ENCODING_RGB32            MMAL_FOURCC('R','G','B','4')
+#define MMAL_ENCODING_RGB32_SLICE      MMAL_FOURCC('r','g','b','4')
 #define MMAL_ENCODING_BGR16            MMAL_FOURCC('B','G','R','2')
+#define MMAL_ENCODING_BGR16_SLICE      MMAL_FOURCC('b','g','r','2')
 #define MMAL_ENCODING_BGR24            MMAL_FOURCC('B','G','R','3')
+#define MMAL_ENCODING_BGR24_SLICE      MMAL_FOURCC('b','g','r','3')
 #define MMAL_ENCODING_BGR32            MMAL_FOURCC('B','G','R','4')
+#define MMAL_ENCODING_BGR32_SLICE      MMAL_FOURCC('b','g','r','4')
+//Bayer formats
+//FourCC values copied from V4L2
+//10 bit per pixel packed Bayer formats.
+#define MMAL_ENCODING_BAYER_SBGGR10P   MMAL_FOURCC('p','B','A','A')  //BGGR
+#define MMAL_ENCODING_BAYER_SGRBG10P   MMAL_FOURCC('p','g','A','A')  //GRBG
+#define MMAL_ENCODING_BAYER_SGBRG10P   MMAL_FOURCC('p','G','A','A')  //GBRG
+#define MMAL_ENCODING_BAYER_SRGGB10P   MMAL_FOURCC('p','R','A','A')  //RGGB
+
+//8 bit per pixel Bayer formats.
+#define MMAL_ENCODING_BAYER_SBGGR8     MMAL_FOURCC('B','A','8','1')  //BGGR
+#define MMAL_ENCODING_BAYER_SGBRG8     MMAL_FOURCC('G','B','R','G')  //GBRG
+#define MMAL_ENCODING_BAYER_SGRBG8     MMAL_FOURCC('G','R','B','G')  //GRBG
+#define MMAL_ENCODING_BAYER_SRGGB8     MMAL_FOURCC('R','G','G','B')  //RGGB
+
+//12 bit per pixel Bayer formats - not defined in V4L2, only 12bit expanded to 16.
+#define MMAL_ENCODING_BAYER_SBGGR12P   MMAL_FOURCC('B','Y','1','2')  //BGGR
+
+//16 bit per pixel Bayer formats.
+#define MMAL_ENCODING_BAYER_SBGGR16    MMAL_FOURCC('B','Y','R','2')  //BGGR
+
+//10 bit per pixel DPCM compressed to 8bits Bayer formats.
+#define MMAL_ENCODING_BAYER_SBGGR10DPCM8 MMAL_FOURCC('b','B','A','8')  //BGGR
+//#define MMAL_ENCODING_BAYER_SGBRG10DPCM8 MMAL_FOURCC('b','G','A','8')  //GBRG
+//#define MMAL_ENCODING_BAYER_SGRBG10DPCM8 MMAL_FOURCC('b','D','A','8')  //GRBG
+//#define MMAL_ENCODING_BAYER_SRGGB10DPCM8 MMAL_FOURCC('b','R','A','8')  //RGGB
 
 /** SAND Video (YUVUV128) format, native format understood by VideoCore.
  * This format is *not* opaque - if requested you will receive full frames
@@ -129,6 +166,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MMAL_ENCODING_WMA2             MMAL_FOURCC('W','M','A','2')
 #define MMAL_ENCODING_WMAP             MMAL_FOURCC('W','M','A','P')
 #define MMAL_ENCODING_WMAL             MMAL_FOURCC('W','M','A','L')
+#define MMAL_ENCODING_WMAV             MMAL_FOURCC('W','M','A','V')
 #define MMAL_ENCODING_AMRNB            MMAL_FOURCC('A','M','R','N')
 #define MMAL_ENCODING_AMRWB            MMAL_FOURCC('A','M','R','W')
 #define MMAL_ENCODING_AMRWBP           MMAL_FOURCC('A','M','R','P')
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_events.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_events.h
index ac82ed0..94ccd56 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_events.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_events.h
@@ -100,15 +100,6 @@ typedef struct MMAL_EVENT_PARAMETER_CHANGED_T
  */
 MMAL_EVENT_FORMAT_CHANGED_T *mmal_event_format_changed_get(MMAL_BUFFER_HEADER_T *buffer);
 
-/** Send an error event to the component's control port.
- * The error event data will be the MMAL_STATUS_T passed in.
- *
- * @param component component to receive the error event.
- * @param error_status the error status to be sent.
- * @return MMAL_SUCCESS or an error if the event could not be sent.
- */
-MMAL_STATUS_T mmal_event_error_send(MMAL_COMPONENT_T *component, MMAL_STATUS_T error_status);
-
 /* @} */
 
 #ifdef __cplusplus
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_camera.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_camera.h
index dd6524b..cba8b52 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_camera.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_camera.h
@@ -136,6 +136,7 @@ enum {
    MMAL_PARAMETER_CAMERA_RX_CONFIG,          /**< Takes a @ref MMAL_PARAMETER_CAMERA_RX_CONFIG_T */
    MMAL_PARAMETER_CAMERA_RX_TIMING,          /**< Takes a @ref MMAL_PARAMETER_CAMERA_RX_TIMING_T */
    MMAL_PARAMETER_DPF_CONFIG,                /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
+   MMAL_PARAMETER_JPEG_RESTART_INTERVAL,     /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
 };
 
 /** Thumbnail configuration parameter type */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_video.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_video.h
index 4688833..a91dbf8 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_video.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_video.h
@@ -101,6 +101,7 @@ enum {
    MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
    MMAL_PARAMETER_VIDEO_ENCODE_SPS_TIMING,         /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T */
    MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS,         /**< Take a @ref MMAL_PARAMETER_UINT32_T */
+   MMAL_PARAMETER_VIDEO_SOURCE_PATTERN,         /**< Take a @ref MMAL_PARAMETER_SOURCE_PATTERN_T */
 };
 
 /** Display transformations.
@@ -486,4 +487,23 @@ typedef struct MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T {
    MMAL_BOOL_T bRepeatFirstField;    /**< Whether to repeat the first field */
 } MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T;
 
+typedef enum MMAL_SOURCE_PATTERN_T {
+   MMAL_VIDEO_SOURCE_PATTERN_WHITE,
+   MMAL_VIDEO_SOURCE_PATTERN_BLACK,
+   MMAL_VIDEO_SOURCE_PATTERN_DIAGONAL,
+   MMAL_VIDEO_SOURCE_PATTERN_NOISE,
+   MMAL_VIDEO_SOURCE_PATTERN_RANDOM,
+   MMAL_VIDEO_SOURCE_PATTERN_COLOUR,
+   MMAL_VIDEO_SOURCE_PATTERN_BLOCKS,
+   MMAL_VIDEO_SOURCE_PATTERN_SWIRLY,
+   MMAL_VIDEO_SOURCE_PATTERN_DUMMY = 0x7fffffff
+} MMAL_SOURCE_PATTERN_T;
+
+typedef struct MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T {
+   MMAL_PARAMETER_HEADER_T hdr;
+
+   MMAL_SOURCE_PATTERN_T pattern;
+} MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T;
+
+
 #endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_queue.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_queue.h
index b85cd1a..ce53a26 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_queue.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_queue.h
@@ -82,6 +82,17 @@ MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue);
  */
 MMAL_BUFFER_HEADER_T *mmal_queue_wait(MMAL_QUEUE_T *queue);
 
+/** Wait for a MMAL_BUFFER_HEADER_T from a queue, up to a given timeout.
+ * This is the same as a wait, except that it will abort in case of timeout.
+ *
+ * @param queue  Pointer to a queue
+ * @param timeout Number of milliseconds to wait before
+ *                returning if the semaphore can't be acquired.
+ *
+ * @return pointer to the next MMAL_BUFFER_HEADER_T.
+ */
+MMAL_BUFFER_HEADER_T *mmal_queue_timedwait(MMAL_QUEUE_T *queue, VCOS_UNSIGNED timeout);
+
 /** Get the number of MMAL_BUFFER_HEADER_T currently in a queue.
  *
  * @param queue  Pointer to a queue
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/CMakeLists.txt
index 66a9009..b2a6858 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/CMakeLists.txt
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/CMakeLists.txt
@@ -1,4 +1,4 @@
-add_library (mmal_util SHARED
+add_library (mmal_util ${LIBRARY_TYPE}
    mmal_il.c
    mmal_util.c
    mmal_connection.c
@@ -13,3 +13,16 @@ add_library (mmal_util SHARED
 target_link_libraries (mmal_util vcos)
 
 install(TARGETS mmal_util DESTINATION lib)
+install(FILES
+   mmal_component_wrapper.h
+   mmal_connection.h
+   mmal_default_components.h
+   mmal_graph.h
+   mmal_il.h
+   mmal_list.h
+   mmal_param_convert.h
+   mmal_util.h
+   mmal_util_params.h
+   mmal_util_rational.h
+   DESTINATION include/interface/mmal/util
+)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.c
index a5f9a8d..485ba77 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.c
@@ -43,11 +43,35 @@ typedef struct
 
 } MMAL_CONNECTION_PRIVATE_T;
 
+/** Callback from a clock port. Buffer is immediately sent to next component. */
+static void mmal_connection_bh_clock_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+   MMAL_STATUS_T status = MMAL_SUCCESS;
+   MMAL_CONNECTION_T *connection = (MMAL_CONNECTION_T *)port->userdata;
+   MMAL_PORT_T *other_port = (port == connection->in) ? connection->out : connection->in;
+
+   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);
+
+   if (other_port->is_enabled)
+   {
+      status = mmal_port_send_buffer(other_port, buffer);
+      if (status != MMAL_SUCCESS)
+      {
+         LOG_ERROR("error sending buffer to clock port (%i)", status);
+         mmal_buffer_header_release(buffer);
+      }
+   }
+   else
+   {
+      mmal_buffer_header_release(buffer);
+   }
+}
+
 /** Callback from an input port. Buffer is released. */
 static void mmal_connection_bh_in_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
-   MMAL_PARAM_UNUSED(port);
    LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);
+
    /* We're done with the buffer, just recycle it */
    mmal_buffer_header_release(buffer);
 }
@@ -56,7 +80,7 @@ static void mmal_connection_bh_in_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *bu
 static void mmal_connection_bh_out_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
    MMAL_CONNECTION_T *connection = (MMAL_CONNECTION_T *)port->userdata;
-   MMAL_PARAM_UNUSED(port);
+
    LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);
 
    /* Queue the buffer produced by the output port */
@@ -191,6 +215,7 @@ MMAL_STATUS_T mmal_connection_create(MMAL_CONNECTION_T **cx,
          LOG_ERROR("failed to propagate buffer requirements");
          goto error;
       }
+      status = MMAL_SUCCESS;
    }
 
    /* Special case for tunnelling */
@@ -226,6 +251,7 @@ MMAL_STATUS_T mmal_connection_create(MMAL_CONNECTION_T **cx,
    return status;
 
  error:
+   /* coverity[var_deref_model] mmal_connection_destroy_internal will check connection->pool correctly */
    mmal_connection_destroy_internal(connection);
    return status == MMAL_SUCCESS ? MMAL_ENOMEM : status;
 }
@@ -268,14 +294,17 @@ MMAL_STATUS_T mmal_connection_enable(MMAL_CONNECTION_T *connection)
    connection->time_enable = vcos_getmicrosecs();
 
    /* Override the buffer values with the recommended ones (the port probably knows best) */
-   if (out->buffer_num_recommended)
-      out->buffer_num = out->buffer_num_recommended;
-   if (out->buffer_size_recommended)
-      out->buffer_size = out->buffer_size_recommended;
-   if (in->buffer_num_recommended)
-      in->buffer_num = in->buffer_num_recommended;
-   if (in->buffer_size_recommended)
-      in->buffer_size = in->buffer_size_recommended;
+   if (!(connection->flags & MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS))
+   {
+      if (out->buffer_num_recommended)
+         out->buffer_num = out->buffer_num_recommended;
+      if (out->buffer_size_recommended)
+         out->buffer_size = out->buffer_size_recommended;
+      if (in->buffer_num_recommended)
+         in->buffer_num = in->buffer_num_recommended;
+      if (in->buffer_size_recommended)
+         in->buffer_size = in->buffer_size_recommended;
+   }
 
    /* Special case for tunnelling */
    if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
@@ -308,7 +337,8 @@ MMAL_STATUS_T mmal_connection_enable(MMAL_CONNECTION_T *connection)
 
    /* Enable output port. The callback specified here is the function which
     * will be called when an empty buffer header comes back to the port. */
-   status = mmal_port_enable(out, mmal_connection_bh_out_cb);
+   status = mmal_port_enable(out, (out->type == MMAL_PORT_TYPE_CLOCK) ?
+                             mmal_connection_bh_clock_cb : mmal_connection_bh_out_cb);
    if(status)
    {
       LOG_ERROR("output port couldn't be enabled");
@@ -317,7 +347,8 @@ MMAL_STATUS_T mmal_connection_enable(MMAL_CONNECTION_T *connection)
 
    /* Enable input port. The callback specified here is the function which
     * will be called when an empty buffer header comes back to the port. */
-   status = mmal_port_enable(in, mmal_connection_bh_in_cb);
+   status = mmal_port_enable(in, (in->type == MMAL_PORT_TYPE_CLOCK) ?
+                             mmal_connection_bh_clock_cb : mmal_connection_bh_in_cb);
    if(status)
    {
       LOG_ERROR("input port couldn't be enabled");
@@ -468,7 +499,7 @@ MMAL_STATUS_T mmal_connection_event_format_changed(MMAL_CONNECTION_T *connection
     * to the next component (so it gets configured properly) */
    if ((connection->in->capabilities & MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE) &&
        event->buffer_size_min <= connection->out->buffer_size &&
-       event->buffer_num_min <= connection->out->buffer_num_min)
+       event->buffer_num_min <= connection->out->buffer_num)
    {
       status = mmal_format_full_copy(connection->out->format, event->format);
       if (status == MMAL_SUCCESS)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.h
index 6aa70b6..d2a02b1 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.h
@@ -94,6 +94,12 @@ extern "C" {
 #define MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT 0x2
 /** Force the pool of buffer headers used by the connection to be allocated on the output port. */
 #define MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT 0x4
+/** Specify that the connection should not modify the buffer requirements. */
+#define MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS 0x8
+/** The connection is flagged as direct. This doesn't change the behaviour of
+ * the connection itself but is used by the the graph utility to specify that
+ * the buffer should be sent to the input port from with the port callback. */
+#define MMAL_CONNECTION_FLAG_DIRECT 0x10
 /* @} */
 
 /** Forward type definition for a connection */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_default_components.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_default_components.h
index 00a31f6..fb0ece4 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_default_components.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_default_components.h
@@ -50,6 +50,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 # define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "avcodec.audio_decode"
 # define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "sdl.audio_render"
 # define MMAL_COMPONENT_DEFAULT_MIRACAST         "miracast"
+# define MMAL_COMPONENT_DEFAULT_CLOCK            "clock"
 #elif defined(__VIDEOCORE__)
 # define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "ril.video_decode"
 # define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "ril.video_encode"
@@ -65,6 +66,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 # define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "none"
 # define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "ril.audio_render"
 # define MMAL_COMPONENT_DEFAULT_MIRACAST         "miracast"
+# define MMAL_COMPONENT_DEFAULT_CLOCK            "clock"
+# define MMAL_COMPONENT_DEFAULT_CAMERA_INFO      "camera_info"
 #else
 # define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "vc.ril.video_decode"
 # define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "vc.ril.video_encode"
@@ -80,6 +83,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 # define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "none"
 # define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "vc.ril.audio_render"
 # define MMAL_COMPONENT_DEFAULT_MIRACAST         "vc.miracast"
+# define MMAL_COMPONENT_DEFAULT_CLOCK            "vc.clock"
+# define MMAL_COMPONENT_DEFAULT_CAMERA_INFO      "vc.camera_info"
 #endif
 
 /** @} */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.c
index cb72375..d66527b 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.c
@@ -33,6 +33,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mmal_logging.h"
 
 #define GRAPH_CONNECTIONS_MAX 16
+#define PROCESSING_TIME_MAX 20000
 
 /*****************************************************************************/
 
@@ -43,15 +44,19 @@ typedef struct MMAL_COMPONENT_MODULE_T
    MMAL_GRAPH_T graph; /**< Must be the first member! */
 
    MMAL_COMPONENT_T *component[GRAPH_CONNECTIONS_MAX];
+   MMAL_GRAPH_TOPOLOGY_T topology[GRAPH_CONNECTIONS_MAX];
    unsigned int component_num;
 
    MMAL_CONNECTION_T *connection[GRAPH_CONNECTIONS_MAX];
    unsigned int connection_num;
+   unsigned int connection_current;
 
    MMAL_PORT_T *input[GRAPH_CONNECTIONS_MAX];
    unsigned int input_num;
    MMAL_PORT_T *output[GRAPH_CONNECTIONS_MAX];
    unsigned int output_num;
+   MMAL_PORT_T *clock[GRAPH_CONNECTIONS_MAX];
+   unsigned int clock_num;
 
    MMAL_COMPONENT_T *graph_component;
 
@@ -69,6 +74,8 @@ typedef MMAL_GRAPH_PRIVATE_T MMAL_COMPONENT_MODULE_T;
 /*****************************************************************************/
 static MMAL_STATUS_T mmal_component_create_from_graph(const char *name, MMAL_COMPONENT_T *component);
 static MMAL_BOOL_T graph_do_processing(MMAL_GRAPH_PRIVATE_T *graph);
+static void graph_process_buffer(MMAL_GRAPH_PRIVATE_T *graph_private,
+   MMAL_CONNECTION_T *connection, MMAL_BUFFER_HEADER_T *buffer);
 
 /*****************************************************************************/
 static void graph_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
@@ -94,6 +101,15 @@ static void graph_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 static void graph_connection_cb(MMAL_CONNECTION_T *connection)
 {
    MMAL_GRAPH_PRIVATE_T *graph = (MMAL_GRAPH_PRIVATE_T *)connection->user_data;
+   MMAL_BUFFER_HEADER_T *buffer;
+
+   if (connection->flags == MMAL_CONNECTION_FLAG_DIRECT &&
+       (buffer = mmal_queue_get(connection->queue)) != NULL)
+   {
+      graph_process_buffer(graph, connection, buffer);
+      return;
+   }
+
    vcos_semaphore_post(&graph->sema);
 }
 
@@ -201,6 +217,36 @@ MMAL_STATUS_T mmal_graph_add_component(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *co
 }
 
 /*****************************************************************************/
+MMAL_STATUS_T mmal_graph_component_topology(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component,
+    MMAL_GRAPH_TOPOLOGY_T topology, int8_t *input, unsigned int input_num,
+    int8_t *output, unsigned int output_num)
+{
+   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
+   MMAL_PARAM_UNUSED(input); MMAL_PARAM_UNUSED(input_num);
+   MMAL_PARAM_UNUSED(output); MMAL_PARAM_UNUSED(output_num);
+   unsigned int i;
+
+   LOG_TRACE("graph: %p, component: %s(%p)", graph, component ? component->name: 0, component);
+
+   if (!component)
+      return MMAL_EINVAL;
+
+   for (i = 0; i < private->component_num; i++)
+      if (component == private->component[i])
+         break;
+
+   if (i == private->component_num)
+      return MMAL_EINVAL; /* Component not found */
+
+   if (topology > MMAL_GRAPH_TOPOLOGY_STRAIGHT)
+      return MMAL_ENOSYS; /* Currently not supported */
+
+   private->topology[i] = topology;
+
+   return MMAL_SUCCESS;
+}
+
+/*****************************************************************************/
 MMAL_STATUS_T mmal_graph_add_connection(MMAL_GRAPH_T *graph, MMAL_CONNECTION_T *cx)
 {
    MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
@@ -230,11 +276,27 @@ MMAL_STATUS_T mmal_graph_add_port(MMAL_GRAPH_T *graph, MMAL_PORT_T *port)
 
    LOG_TRACE("graph: %p, port: %s(%p)", graph, port ? port->name: 0, port);
 
-   if (!port || (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT))
+   if (!port)
       return MMAL_EINVAL;
 
-   list = port->type == MMAL_PORT_TYPE_INPUT ? private->input : private->output;
-   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &private->input_num : &private->output_num;
+   switch (port->type)
+   {
+   case MMAL_PORT_TYPE_INPUT:
+      list = private->input;
+      list_num = &private->input_num;
+      break;
+   case MMAL_PORT_TYPE_OUTPUT:
+      list = private->output;
+      list_num = &private->output_num;
+      break;
+   case MMAL_PORT_TYPE_CLOCK:
+      list = private->clock;
+      list_num = &private->clock_num;
+      break;
+   default:
+      return MMAL_EINVAL;
+   }
+
    if (*list_num >= GRAPH_CONNECTIONS_MAX)
    {
       LOG_ERROR("no space for port %s", port->name);
@@ -286,8 +348,12 @@ MMAL_STATUS_T mmal_graph_new_connection(MMAL_GRAPH_T *graph, MMAL_PORT_T *out, M
    MMAL_CONNECTION_T *cx;
    MMAL_STATUS_T status;
 
-   if (!out || !in ||
-       out->type != MMAL_PORT_TYPE_OUTPUT || in->type != MMAL_PORT_TYPE_INPUT)
+   if (!out || !in)
+      return MMAL_EINVAL;
+   if (out->type == MMAL_PORT_TYPE_CLOCK && in->type != MMAL_PORT_TYPE_CLOCK)
+      return MMAL_EINVAL;
+   if (out->type != MMAL_PORT_TYPE_CLOCK &&
+       (out->type != MMAL_PORT_TYPE_OUTPUT || in->type != MMAL_PORT_TYPE_INPUT))
       return MMAL_EINVAL;
 
    LOG_TRACE("graph: %p, out: %s(%p), in: %s(%p), flags %x, connection: %p",
@@ -406,8 +472,20 @@ MMAL_STATUS_T mmal_graph_component_constructor(const char *name,
 static void graph_component_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
    MMAL_COMPONENT_T *graph_component = (MMAL_COMPONENT_T *)port->userdata;
+   MMAL_GRAPH_PRIVATE_T *graph_private = graph_component->priv->module;
+   MMAL_STATUS_T status;
+
    LOG_TRACE("%s(%p),%p,%4.4s", port->name, port, buffer, (char *)&buffer->cmd);
 
+   /* Call user defined function first */
+   if (graph_private->graph.pf_control_callback)
+   {
+      status = graph_private->graph.pf_control_callback(&graph_private->graph,
+         port, buffer);
+      if (status != MMAL_ENOSYS)
+         return;
+   }
+
    /* Forward the event on the graph control port */
    mmal_port_event_send(graph_component->control, buffer);
 }
@@ -416,6 +494,16 @@ static void graph_component_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *
 static void graph_component_connection_cb(MMAL_CONNECTION_T *connection)
 {
    MMAL_COMPONENT_T *component = (MMAL_COMPONENT_T *)connection->user_data;
+   MMAL_BUFFER_HEADER_T *buffer;
+
+   if (connection->flags == MMAL_CONNECTION_FLAG_DIRECT &&
+       (buffer = mmal_queue_get(connection->queue)) != NULL)
+   {
+      graph_process_buffer((MMAL_GRAPH_PRIVATE_T *)component->priv->module,
+         connection, buffer);
+      return;
+   }
+
    mmal_component_action_trigger(component);
 }
 
@@ -456,63 +544,95 @@ static void graph_port_event_handler(MMAL_CONNECTION_T *connection,
 }
 
 /*****************************************************************************/
-static MMAL_BOOL_T graph_do_processing(MMAL_GRAPH_PRIVATE_T *graph)
+static void graph_process_buffer(MMAL_GRAPH_PRIVATE_T *graph_private,
+   MMAL_CONNECTION_T *connection, MMAL_BUFFER_HEADER_T *buffer)
 {
-   MMAL_BUFFER_HEADER_T *buffer;
-   MMAL_BOOL_T run_again = 0;
    MMAL_STATUS_T status;
-   unsigned int i;
 
-   /* Loop through all the connections */
-   for (i = 0; i < graph->connection_num; i++)
+   /* Call user defined function first */
+   if (graph_private->graph.pf_connection_buffer)
    {
-      MMAL_CONNECTION_T *connection = graph->connection[i];
+      status = graph_private->graph.pf_connection_buffer(&graph_private->graph, connection, buffer);
+      if (status != MMAL_ENOSYS)
+         return;
+   }
 
-      if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
-         continue; /* Nothing else to do in tunnelling mode */
+   if (buffer->cmd)
+   {
+      graph_port_event_handler(connection, connection->out, buffer);
+      return;
+   }
 
-      /* Send any queued buffer to the next component */
-      buffer = mmal_queue_get(connection->queue);
-      while (buffer)
-      {
-         run_again = 1;
+   status = mmal_port_send_buffer(connection->in, buffer);
+   if (status != MMAL_SUCCESS)
+   {
+      LOG_ERROR("%s(%p) could not send buffer to %s(%p) (%s)",
+                connection->out->name, connection->out,
+                connection->in->name, connection->in,
+                mmal_status_to_string(status));
+      mmal_buffer_header_release(buffer);
+      mmal_event_error_send(connection->out->component, status);
+   }
+}
 
-         if (buffer->cmd)
-         {
-            graph_port_event_handler(connection, connection->out, buffer);
-            buffer = mmal_queue_get(connection->queue);
-            continue;
-         }
+/*****************************************************************************/
+static MMAL_BOOL_T graph_do_processing(MMAL_GRAPH_PRIVATE_T *graph_private)
+{
+   MMAL_BUFFER_HEADER_T *buffer;
+   MMAL_BOOL_T run_again = 0;
+   MMAL_STATUS_T status;
+   unsigned int i, j;
 
-         status = mmal_port_send_buffer(connection->in, buffer);
-         if (status != MMAL_SUCCESS)
-         {
-            LOG_ERROR("%s(%p) could not send buffer to %s(%p) (%s)",
-                      connection->out->name, connection->out,
-                      connection->in->name, connection->in,
-                      mmal_status_to_string(status));
-            mmal_buffer_header_release(buffer);
-            mmal_event_error_send(connection->out->component, status);
-         }
-         buffer = mmal_queue_get(connection->queue);
-      }
+   /* Process all the empty buffers first */
+   for (i = 0, j = graph_private->connection_current;
+        i < graph_private->connection_num; i++, j++)
+   {
+      MMAL_CONNECTION_T *connection =
+         graph_private->connection[j%graph_private->connection_num];
+
+      if ((connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING) ||
+          !connection->pool)
+         continue; /* Nothing else to do in tunnelling mode */
 
       /* Send empty buffers to the output port of the connection */
-      buffer = connection->pool ? mmal_queue_get(connection->pool->queue) : NULL;
-      while (buffer)
+      while ((buffer = mmal_queue_get(connection->pool->queue)) != NULL)
       {
          run_again = 1;
 
          status = mmal_port_send_buffer(connection->out, buffer);
          if (status != MMAL_SUCCESS)
          {
-            LOG_ERROR("mmal_port_send_buffer failed (%i)", status);
+            if (connection->out->is_enabled)
+               LOG_ERROR("mmal_port_send_buffer failed (%i)", status);
             mmal_queue_put_back(connection->pool->queue, buffer);
             run_again = 0;
-            // FIXME: send error ?
             break;
          }
-         buffer = mmal_queue_get(connection->pool->queue);
+      }
+   }
+
+   /* Loop through all the connections */
+   for (i = 0, j = graph_private->connection_current++;
+        i < graph_private->connection_num; i++, j++)
+   {
+      MMAL_CONNECTION_T *connection =
+         graph_private->connection[j%graph_private->connection_num];
+      int64_t duration = vcos_getmicrosecs64();
+
+      if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
+         continue; /* Nothing else to do in tunnelling mode */
+      if (connection->flags & MMAL_CONNECTION_FLAG_DIRECT)
+         continue; /* Nothing else to do in direct mode */
+
+      /* Send any queued buffer to the next component.
+       * We also make sure no connection can starve the others by
+       * having a timeout. */
+      while (vcos_getmicrosecs64() - duration < PROCESSING_TIME_MAX &&
+             (buffer = mmal_queue_get(connection->queue)) != NULL)
+      {
+         run_again = 1;
+
+         graph_process_buffer(graph_private, connection, buffer);
       }
    }
 
@@ -531,11 +651,24 @@ static MMAL_PORT_T *find_port_from_graph(MMAL_GRAPH_PRIVATE_T *graph, MMAL_PORT_
    MMAL_PORT_T **list;
    unsigned int *list_num;
 
-   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
+   switch (port->type)
+   {
+   case MMAL_PORT_TYPE_INPUT:
+      list = graph->input;
+      list_num = &graph->input_num;
+      break;
+   case MMAL_PORT_TYPE_OUTPUT:
+      list = graph->output;
+      list_num = &graph->output_num;
+      break;
+   case MMAL_PORT_TYPE_CLOCK:
+      list = graph->clock;
+      list_num = &graph->clock_num;
+      break;
+   default:
       return 0;
+   }
 
-   list = port->type == MMAL_PORT_TYPE_INPUT ? graph->input : graph->output;
-   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &graph->input_num : &graph->output_num;
    if (port->index > *list_num)
       return 0;
 
@@ -545,14 +678,29 @@ static MMAL_PORT_T *find_port_from_graph(MMAL_GRAPH_PRIVATE_T *graph, MMAL_PORT_
 static MMAL_PORT_T *find_port_to_graph(MMAL_GRAPH_PRIVATE_T *graph, MMAL_PORT_T *port)
 {
    MMAL_COMPONENT_T *component = graph->graph_component;
-   MMAL_PORT_T **list;
+   MMAL_PORT_T **list, **component_list;
    unsigned int i, *list_num;
 
-   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
+   switch (port->type)
+   {
+   case MMAL_PORT_TYPE_INPUT:
+      list = graph->input;
+      list_num = &graph->input_num;
+      component_list = component->input;
+      break;
+   case MMAL_PORT_TYPE_OUTPUT:
+      list = graph->output;
+      list_num = &graph->output_num;
+      component_list = component->output;
+      break;
+   case MMAL_PORT_TYPE_CLOCK:
+      list = graph->clock;
+      list_num = &graph->clock_num;
+      component_list = component->clock;
+      break;
+   default:
       return 0;
-
-   list = port->type == MMAL_PORT_TYPE_INPUT ? graph->input : graph->output;
-   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &graph->input_num : &graph->output_num;
+   }
 
    for (i = 0; i < *list_num; i++)
       if (list[i] == port)
@@ -560,7 +708,7 @@ static MMAL_PORT_T *find_port_to_graph(MMAL_GRAPH_PRIVATE_T *graph, MMAL_PORT_T
 
    if (i == *list_num)
       return 0;
-   return port->type == MMAL_PORT_TYPE_INPUT ? component->input[i] : component->output[i];
+   return component_list[i];
 }
 
 static MMAL_STATUS_T graph_port_update(MMAL_GRAPH_PRIVATE_T *graph,
@@ -633,6 +781,9 @@ static MMAL_STATUS_T graph_component_destroy(MMAL_COMPONENT_T *component)
    if (component->output_num)
       mmal_ports_free(component->output, component->output_num);
 
+   if (component->clock_num)
+      mmal_ports_clock_free(component->clock, component->clock_num);
+
    /* coverity[address_free] Freeing the first item in the structure is safe */
    mmal_graph_destroy(&graph->graph);
    return MMAL_SUCCESS;
@@ -641,15 +792,27 @@ static MMAL_STATUS_T graph_component_destroy(MMAL_COMPONENT_T *component)
 /** Enable processing on a component */
 static MMAL_STATUS_T graph_component_enable(MMAL_COMPONENT_T *component)
 {
-   MMAL_PARAM_UNUSED(component);
-   return MMAL_SUCCESS;
+   MMAL_GRAPH_PRIVATE_T *graph_private = component->priv->module;
+   MMAL_STATUS_T status = MMAL_ENOSYS;
+
+   /* Call user defined function first */
+   if (graph_private->graph.pf_graph_enable)
+      status = graph_private->graph.pf_graph_enable(&graph_private->graph, MMAL_TRUE);
+
+   return status;
 }
 
 /** Disable processing on a component */
 static MMAL_STATUS_T graph_component_disable(MMAL_COMPONENT_T *component)
 {
-   MMAL_PARAM_UNUSED(component);
-   return MMAL_SUCCESS;
+   MMAL_GRAPH_PRIVATE_T *graph_private = component->priv->module;
+   MMAL_STATUS_T status = MMAL_ENOSYS;
+
+   /* Call user defined function first */
+   if (graph_private->graph.pf_graph_enable)
+      status = graph_private->graph.pf_graph_enable(&graph_private->graph, MMAL_FALSE);
+
+   return status;
 }
 
 /** Callback given to mmal_port_enable() */
@@ -682,6 +845,26 @@ static void graph_port_enable_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer
       mmal_port_buffer_header_callback(graph_port, buffer);
 }
 
+/** Check whether 2 ports of a component are linked */
+static MMAL_BOOL_T graph_component_topology_ports_linked(MMAL_GRAPH_PRIVATE_T *graph,
+   MMAL_PORT_T *port1, MMAL_PORT_T *port2)
+{
+   MMAL_COMPONENT_T *component = port1->component;
+   unsigned int i;
+
+   for (i = 0; i < graph->component_num; i++)
+      if (component == graph->component[i])
+         break;
+
+   if (i == graph->component_num)
+      return MMAL_FALSE; /* Component not found */
+
+   if (graph->topology[i] == MMAL_GRAPH_TOPOLOGY_STRAIGHT)
+      return port1->index == port2->index;
+
+   return MMAL_TRUE;
+}
+
 /** Propagate a port enable */
 static MMAL_STATUS_T graph_port_state_propagate(MMAL_GRAPH_PRIVATE_T *graph,
    MMAL_PORT_T *port, MMAL_BOOL_T enable)
@@ -718,6 +901,9 @@ static MMAL_STATUS_T graph_port_state_propagate(MMAL_GRAPH_PRIVATE_T *graph,
       if (j == graph->connection_num)
          continue; /* No match */
 
+      if (!graph_component_topology_ports_linked(graph, port, component->port[i]))
+            continue; /* Ports are independent */
+
       if (enable)
       {
          status = mmal_connection_enable(graph->connection[j]);
@@ -760,6 +946,14 @@ static MMAL_STATUS_T graph_port_enable(MMAL_PORT_T *graph_port, MMAL_PORT_BH_CB_
    port->buffer_num = graph_port->buffer_num;
    port->buffer_size = graph_port->buffer_size;
 
+   /* Call user defined function first */
+   if (graph_private->graph.pf_enable)
+   {
+      status = graph_private->graph.pf_enable(&graph_private->graph, graph_port);
+      if (status != MMAL_ENOSYS)
+         return status;
+   }
+
    /* We'll intercept the callback */
    port->userdata = (void *)graph_private;
    status = mmal_port_enable(port, graph_port_enable_cb);
@@ -777,12 +971,21 @@ static MMAL_STATUS_T graph_port_enable(MMAL_PORT_T *graph_port, MMAL_PORT_BH_CB_
 static MMAL_STATUS_T graph_port_disable(MMAL_PORT_T *graph_port)
 {
    MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
+   MMAL_STATUS_T status;
    MMAL_PORT_T *port;
 
    port = find_port_from_graph(graph_port->component->priv->module, graph_port);
    if (!port)
       return MMAL_EINVAL;
 
+   /* Call user defined function first */
+   if (graph_private->graph.pf_disable)
+   {
+      status = graph_private->graph.pf_disable(&graph_private->graph, graph_port);
+      if (status != MMAL_ENOSYS)
+         return status;
+   }
+
    /* We need to disable all the connected connections.
     * Since disable does an implicit flush, we only want to do that if
     * we're acting on an input port or we risk discarding buffers along
@@ -832,6 +1035,9 @@ static MMAL_STATUS_T graph_port_flush_propagate(MMAL_GRAPH_PRIVATE_T *graph,
       if (j == graph->connection_num)
          continue; /* No match */
 
+      if (!graph_component_topology_ports_linked(graph, port, component->port[i]))
+         continue; /* Ports are independent */
+
       /* Flush any buffer waiting in the connection queue */
       if (graph->connection[j]->queue)
       {
@@ -907,7 +1113,7 @@ static MMAL_STATUS_T graph_port_format_commit_propagate(MMAL_GRAPH_PRIVATE_T *gr
 
    LOG_TRACE("graph: %p, port %s(%p)", graph, port->name, port);
 
-   if (port->type == MMAL_PORT_TYPE_OUTPUT)
+   if (port->type == MMAL_PORT_TYPE_OUTPUT || port->type == MMAL_PORT_TYPE_CLOCK)
       return MMAL_SUCCESS; /* Nothing to do */
 
    /* Loop through all the output ports of the component and if they are not enabled and
@@ -927,6 +1133,9 @@ static MMAL_STATUS_T graph_port_format_commit_propagate(MMAL_GRAPH_PRIVATE_T *gr
       if (j == graph->connection_num)
          continue; /* No match */
 
+      if (!graph_component_topology_ports_linked(graph, port, component->output[i]))
+         continue; /* Ports are independent */
+
       in = graph->connection[j]->in;
       out = graph->connection[j]->out;
 
@@ -1242,6 +1451,34 @@ static MMAL_STATUS_T mmal_component_create_from_graph(const char *name, MMAL_COM
       if (status != MMAL_SUCCESS)
          goto error;
    }
+   if(graph->clock_num)
+   {
+      component->clock = mmal_ports_clock_alloc(component, graph->clock_num, 0, NULL);
+      if(!component->clock)
+      {
+         status = MMAL_ENOMEM;
+         goto error;
+      }
+   }
+   component->clock_num = graph->clock_num;
+   for(i = 0; i < component->clock_num; i++)
+   {
+      component->clock[i]->priv->pf_enable = graph_port_enable;
+      component->clock[i]->priv->pf_disable = graph_port_disable;
+      component->clock[i]->priv->pf_flush = graph_port_flush;
+      component->clock[i]->priv->pf_send = graph_port_send;
+      component->clock[i]->priv->pf_set_format = graph_port_format_commit;
+      component->clock[i]->priv->pf_parameter_get = graph_port_parameter_get;
+      component->clock[i]->priv->pf_parameter_set = graph_port_parameter_set;
+      component->clock[i]->priv->pf_connect = NULL; /* FIXME: disabled for now */
+      component->clock[i]->priv->pf_payload_alloc = graph_port_payload_alloc;
+      component->clock[i]->priv->pf_payload_free = graph_port_payload_free;
+
+      /* Mirror the port values */
+      status = graph_port_update(graph, component->clock[i], MMAL_TRUE);
+      if (status != MMAL_SUCCESS)
+         goto error;
+   }
 
    status = mmal_component_action_register(component, graph_do_processing_loop);
    if (status != MMAL_SUCCESS)
@@ -1299,6 +1536,10 @@ MMAL_PORT_T *mmal_graph_find_port(MMAL_GRAPH_T *graph,
             num = comp->output_num;
             ports = comp->output;
          }
+         else if (type == MMAL_PORT_TYPE_CLOCK) {
+            num = comp->clock_num;
+            ports = comp->clock;
+         }
          else if (type == MMAL_PORT_TYPE_CONTROL) {
             num = 1;
             ports = &comp->control;
@@ -1309,6 +1550,7 @@ MMAL_PORT_T *mmal_graph_find_port(MMAL_GRAPH_T *graph,
          }
          if (index < num)
          {
+            /* coverity[ptr_arith] num is 1 at this point */
             return ports[index];
          }
       }
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.h
index ef8fab7..e6284ba 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.h
@@ -41,6 +41,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 extern "C" {
 #endif
 
+/** List of topology types */
+typedef enum
+{
+   MMAL_GRAPH_TOPOLOGY_ALL = 0,    /**< All input ports and output ports are linked */
+   MMAL_GRAPH_TOPOLOGY_STRAIGHT,   /**< Input ports and output ports of the same index are linked */
+   MMAL_GRAPH_TOPOLOGY_CUSTOM,     /**< Custom defined topology */
+   MMAL_GRAPH_TOPOLOGY_MAX
+
+} MMAL_GRAPH_TOPOLOGY_T;
+
 /** Structure describing a graph */
 typedef struct MMAL_GRAPH_T
 {
@@ -66,6 +76,18 @@ typedef struct MMAL_GRAPH_T
    MMAL_STATUS_T (*pf_payload_free)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, uint8_t *payload);
    /** Optional callback that the client can set to intercept flush calls on ports exposed by the graph */
    MMAL_STATUS_T (*pf_flush)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
+   /** Optional callback that the client can set to control callbacks from the internal components of the graph */
+   /** Optional callback that the client can set to intercept enable calls on ports exposed by the graph */
+   MMAL_STATUS_T (*pf_enable)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
+   /** Optional callback that the client can set to intercept disable calls on ports exposed by the graph */
+   MMAL_STATUS_T (*pf_disable)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
+   /** Optional callback that the client can set to control callbacks from the internal components of the graph */
+   MMAL_STATUS_T (*pf_control_callback)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
+   /** Optional callback that the client can set to intercept component_enable/disable calls made to the graph */
+   MMAL_STATUS_T (*pf_graph_enable)(struct MMAL_GRAPH_T *, MMAL_BOOL_T enable);
+   /** Optional callback that the client can set to intercept buffers going through internal connections.
+    * This will only be triggered if the connection is not tunnelled */
+   MMAL_STATUS_T (*pf_connection_buffer)(struct MMAL_GRAPH_T *, MMAL_CONNECTION_T *connection, MMAL_BUFFER_HEADER_T *buffer);
 
 } MMAL_GRAPH_T;
 
@@ -87,6 +109,25 @@ MMAL_STATUS_T mmal_graph_create(MMAL_GRAPH_T **graph, unsigned int userdata_size
  */
 MMAL_STATUS_T mmal_graph_add_component(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component);
 
+/** Describe the topology of the ports of a component.
+ * Allows the client to describe the topology of a component. This information
+ * is used by the graph to choose which action to perform when
+ * enabling / disabling / committing / flushing a port exposed by the graph.
+ * Note that by default the topology of a component is set to MMAL_GRAPH_TOPOLOGY_ALL.
+ *
+ * @param graph instance of the graph
+ * @param component component to describe
+ * @param topology type of topology used by this component
+ * @param input output index (or -1 if sink) linked to each input port
+ * @param input_num number of indexes in the input list
+ * @param output input index (or -1 if source) linked to each output port
+ * @param output_num number of indexes in the output list
+ * @return MMAL_SUCCESS on success
+ */
+MMAL_STATUS_T mmal_graph_component_topology(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component,
+    MMAL_GRAPH_TOPOLOGY_T topology, int8_t *input, unsigned int input_num,
+    int8_t *output, unsigned int output_num);
+
 /** Add a port to a graph.
  * Allows the client to add an input or output port to a graph. The given port
  * will effectively become an end point for the graph.
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.c
index 085a818..681d5d5 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.c
@@ -80,6 +80,20 @@ OMX_U32 mmalil_buffer_flags_to_omx(uint32_t flags)
       omx_flags |= OMX_BUFFERFLAG_CAPTURE_PREVIEW;
    if (flags & MMAL_BUFFER_HEADER_FLAG_CORRUPTED)
       omx_flags |= OMX_BUFFERFLAG_DATACORRUPT;
+   if (flags & MMAL_BUFFER_HEADER_FLAG_DECODEONLY)
+      omx_flags |= OMX_BUFFERFLAG_DECODEONLY;
+   if (flags & MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED)
+      omx_flags |= OMX_BUFFERFLAG_INTERLACED;
+   if (flags & MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST)
+     omx_flags |= OMX_BUFFERFLAG_TOP_FIELD_FIRST;
+   if (flags & MMAL_BUFFER_HEADER_FLAG_USER0)
+      omx_flags |= 1<<28;
+   if (flags & MMAL_BUFFER_HEADER_FLAG_USER1)
+      omx_flags |= 1<<29;
+   if (flags & MMAL_BUFFER_HEADER_FLAG_USER2)
+      omx_flags |= 1<<30;
+   if (flags & MMAL_BUFFER_HEADER_FLAG_USER3)
+      omx_flags |= 1<<31;
 
    return omx_flags;
 }
@@ -104,6 +118,20 @@ uint32_t mmalil_buffer_flags_to_mmal(OMX_U32 flags)
       mmal_flags |= MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT;
    if (flags & OMX_BUFFERFLAG_DATACORRUPT)
       mmal_flags |= MMAL_BUFFER_HEADER_FLAG_CORRUPTED;
+   if (flags & OMX_BUFFERFLAG_DECODEONLY)
+      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_DECODEONLY;
+   if (flags & OMX_BUFFERFLAG_INTERLACED)
+      mmal_flags |= MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED;
+   if (flags & OMX_BUFFERFLAG_TOP_FIELD_FIRST)
+      mmal_flags |= MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST;
+   if (flags & 1<<28)
+      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_USER0;
+   if (flags & 1<<29)
+      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_USER1;
+   if (flags & 1<<30)
+      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_USER2;
+   if (flags & 1<<31)
+      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_USER3;
 
    return mmal_flags;
 }
@@ -119,8 +147,16 @@ void mmalil_buffer_header_to_omx(OMX_BUFFERHEADERTYPE *omx, MMAL_BUFFER_HEADER_T
    omx->nTimeStamp = omx_ticks_from_s64(mmal->pts);
    if (mmal->pts == MMAL_TIME_UNKNOWN)
    {
-      omx->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
-      omx->nTimeStamp = omx_ticks_from_s64(0);
+      if (mmal->dts == MMAL_TIME_UNKNOWN)
+      {
+         omx->nTimeStamp = omx_ticks_from_s64(0);
+         omx->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
+      }
+      else
+      {
+        omx->nTimeStamp = omx_ticks_from_s64(mmal->dts);
+        omx->nFlags |= OMX_BUFFERFLAG_TIME_IS_DTS;
+      }
    }
 }
 
@@ -131,10 +167,21 @@ void mmalil_buffer_header_to_mmal(MMAL_BUFFER_HEADER_T *mmal, OMX_BUFFERHEADERTY
    mmal->alloc_size = omx->nAllocLen;
    mmal->length = omx->nFilledLen;
    mmal->offset = omx->nOffset;
-   mmal->pts = omx_ticks_to_s64(omx->nTimeStamp);
-   if (omx->nFlags & OMX_BUFFERFLAG_TIME_UNKNOWN)
-      mmal->pts = MMAL_TIME_UNKNOWN;
-   mmal->dts = MMAL_TIME_UNKNOWN;
+   if (omx->nFlags & OMX_BUFFERFLAG_TIME_IS_DTS)
+   {
+     mmal->dts = omx_ticks_to_s64(omx->nTimeStamp);
+     mmal->pts = MMAL_TIME_UNKNOWN;
+   }
+   else if (omx->nFlags & OMX_BUFFERFLAG_TIME_UNKNOWN)
+   {
+     mmal->dts = MMAL_TIME_UNKNOWN;
+     mmal->pts = MMAL_TIME_UNKNOWN;
+   }
+   else
+   {
+     mmal->dts = MMAL_TIME_UNKNOWN;
+     mmal->pts = omx_ticks_to_s64(omx->nTimeStamp);
+   }
    mmal->flags = mmalil_buffer_flags_to_mmal(omx->nFlags);
 }
 
@@ -186,6 +233,9 @@ static struct {
    {MMAL_ENCODING_PCM_UNSIGNED_LE,OMX_AUDIO_CodingPCM},
    {MMAL_ENCODING_PCM_SIGNED_BE,  OMX_AUDIO_CodingPCM},
    {MMAL_ENCODING_PCM_UNSIGNED_BE,OMX_AUDIO_CodingPCM},
+   {MMAL_ENCODING_AC3,            OMX_AUDIO_CodingDDP},
+   {MMAL_ENCODING_EAC3,           OMX_AUDIO_CodingDDP},
+   {MMAL_ENCODING_DTS,            OMX_AUDIO_CodingDTS},
    {MMAL_ENCODING_UNKNOWN,        OMX_AUDIO_CodingUnused}
 };
 
@@ -236,9 +286,20 @@ static struct {
    {OMX_AUDIO_CodingWMA, OMX_IndexParamAudioWma, sizeof(OMX_AUDIO_PARAM_WMATYPE)},
    {OMX_AUDIO_CodingRA, OMX_IndexParamAudioRa, sizeof(OMX_AUDIO_PARAM_RATYPE)},
    {OMX_AUDIO_CodingMIDI, OMX_IndexParamAudioMidi, sizeof(OMX_AUDIO_PARAM_MIDITYPE)},
+   {OMX_AUDIO_CodingDDP, OMX_IndexParamAudioDdp, sizeof(OMX_AUDIO_PARAM_DDPTYPE)},
+   {OMX_AUDIO_CodingDTS, OMX_IndexParamAudioDts, sizeof(OMX_AUDIO_PARAM_DTSTYPE)},
    {OMX_AUDIO_CodingUnused, 0, 0}
 };
 
+OMX_AUDIO_CODINGTYPE mmalil_omx_audio_param_index_to_coding(OMX_INDEXTYPE index)
+{
+   unsigned int i;
+   for(i = 0; mmal_omx_audio_format_table[i].coding != OMX_AUDIO_CodingUnused; i++)
+      if(mmal_omx_audio_format_table[i].index == index) break;
+
+   return mmal_omx_audio_format_table[i].coding;
+}
+
 OMX_INDEXTYPE mmalil_omx_audio_param_index(OMX_AUDIO_CODINGTYPE coding, OMX_U32 *size)
 {
    unsigned int i;
@@ -249,11 +310,41 @@ OMX_INDEXTYPE mmalil_omx_audio_param_index(OMX_AUDIO_CODINGTYPE coding, OMX_U32
    return mmal_omx_audio_format_table[i].index;
 }
 
+MMAL_STATUS_T mmalil_omx_default_channel_mapping(OMX_AUDIO_CHANNELTYPE *channel_mapping, unsigned int nchannels)
+{
+   static const OMX_AUDIO_CHANNELTYPE default_mapping[][8] = {
+      {OMX_AUDIO_ChannelNone},
+      {OMX_AUDIO_ChannelCF},
+      {OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF},
+      {OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF, OMX_AUDIO_ChannelCF},
+      {OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF, OMX_AUDIO_ChannelCF,
+         OMX_AUDIO_ChannelCS},
+      {OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF, OMX_AUDIO_ChannelCF,
+         OMX_AUDIO_ChannelLR, OMX_AUDIO_ChannelRR},
+      {OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF, OMX_AUDIO_ChannelCF,
+         OMX_AUDIO_ChannelLFE, OMX_AUDIO_ChannelLR, OMX_AUDIO_ChannelRR},
+      {OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF, OMX_AUDIO_ChannelCF,
+         OMX_AUDIO_ChannelLFE, OMX_AUDIO_ChannelLR, OMX_AUDIO_ChannelRR,
+         OMX_AUDIO_ChannelCS},
+      {OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF, OMX_AUDIO_ChannelCF,
+         OMX_AUDIO_ChannelLFE, OMX_AUDIO_ChannelLR, OMX_AUDIO_ChannelRR,
+         OMX_AUDIO_ChannelLS, OMX_AUDIO_ChannelRS}
+   };
+
+   if (!nchannels || nchannels >= MMAL_COUNTOF(default_mapping))
+      return MMAL_EINVAL;
+
+   memcpy(channel_mapping, default_mapping[nchannels],
+      sizeof(default_mapping[0][0]) * nchannels);
+   return MMAL_SUCCESS;
+}
+
 MMAL_FOURCC_T mmalil_omx_audio_param_to_format(MMAL_ES_FORMAT_T *format,
    OMX_AUDIO_CODINGTYPE coding, OMX_FORMAT_PARAM_TYPE *param)
 {
    MMAL_AUDIO_FORMAT_T *audio = &format->es->audio;
-   format->encoding = MMAL_ENCODING_UNKNOWN;
+   format->encoding = mmalil_omx_audio_coding_to_encoding(coding);
+   format->encoding_variant = 0;
 
    switch(coding)
    {
@@ -324,7 +415,6 @@ MMAL_FOURCC_T mmalil_omx_audio_param_to_format(MMAL_ES_FORMAT_T *format,
       }
       break;
    case OMX_AUDIO_CodingVORBIS:
-      format->encoding = MMAL_ENCODING_VORBIS;
       audio->channels = param->vorbis.nChannels;
       audio->sample_rate = param->vorbis.nSampleRate;
       format->bitrate = param->vorbis.nBitRate;
@@ -340,6 +430,18 @@ MMAL_FOURCC_T mmalil_omx_audio_param_to_format(MMAL_ES_FORMAT_T *format,
          param->amr.eAMRBandMode <= OMX_AUDIO_AMRBandModeWB8)
          format->encoding = MMAL_ENCODING_AMRWB;
       break;
+   case OMX_AUDIO_CodingDDP:
+      audio->channels = param->ddp.nChannels;
+      audio->sample_rate = param->ddp.nSampleRate;
+      if(param->ddp.eBitStreamId > OMX_AUDIO_DDPBitStreamIdAC3)
+         format->encoding = MMAL_ENCODING_EAC3;
+      break;
+   case OMX_AUDIO_CodingDTS:
+      audio->channels = param->dts.nChannels;
+      audio->sample_rate = param->dts.nSampleRate;
+      audio->block_align = param->dts.nDtsFrameSizeBytes;
+      break;
+
    case OMX_AUDIO_CodingADPCM:
    case OMX_AUDIO_CodingGSMFR:
    case OMX_AUDIO_CodingGSMEFR:
@@ -386,15 +488,7 @@ OMX_AUDIO_CODINGTYPE mmalil_format_to_omx_audio_param(OMX_FORMAT_PARAM_TYPE *par
       param->pcm.nChannels = audio->channels;
       param->pcm.nSamplingRate = audio->sample_rate;
       param->pcm.nBitPerSample = audio->bits_per_sample;
-      if(audio->channels == 1)
-      {
-         param->pcm.eChannelMapping[0] = OMX_AUDIO_ChannelCF;
-      }
-      else if(audio->channels == 2)
-      {
-         param->pcm.eChannelMapping[0] = OMX_AUDIO_ChannelLF;
-         param->pcm.eChannelMapping[1] = OMX_AUDIO_ChannelRF;
-      }
+      mmalil_omx_default_channel_mapping(param->pcm.eChannelMapping, audio->channels);
       if(format->encoding == MMAL_ENCODING_PCM_SIGNED_BE ||
          format->encoding == MMAL_ENCODING_PCM_SIGNED_LE ||
          format->encoding == MMAL_ENCODING_PCM_UNSIGNED_BE ||
@@ -465,6 +559,24 @@ OMX_AUDIO_CODINGTYPE mmalil_format_to_omx_audio_param(OMX_FORMAT_PARAM_TYPE *par
       if(format->encoding == MMAL_ENCODING_AMRWB)
          param->amr.eAMRBandMode = OMX_AUDIO_AMRBandModeWB0;
       break;
+   case OMX_AUDIO_CodingDDP:
+      param->ddp.nChannels = audio->channels;
+      param->ddp.nSampleRate = audio->sample_rate;
+      param->ddp.eBitStreamId = OMX_AUDIO_DDPBitStreamIdAC3;
+      if(format->encoding == MMAL_ENCODING_EAC3)
+         param->ddp.eBitStreamId = OMX_AUDIO_DDPBitStreamIdEAC3;
+      param->ddp.eBitStreamMode = 0;
+      param->ddp.eDolbySurroundMode = 0;
+      mmalil_omx_default_channel_mapping(param->ddp.eChannelMapping, audio->channels);
+      break;
+   case OMX_AUDIO_CodingDTS:
+      param->dts.nChannels = audio->channels;
+      param->dts.nSampleRate = audio->sample_rate;
+      param->dts.nDtsFrameSizeBytes = audio->block_align;
+      param->dts.nDtsType = 1;
+      param->dts.nFormat = 0;
+      mmalil_omx_default_channel_mapping(param->dts.eChannelMapping, audio->channels);
+      break;
    case OMX_AUDIO_CodingADPCM:
    case OMX_AUDIO_CodingGSMFR:
    case OMX_AUDIO_CodingGSMEFR:
@@ -500,19 +612,21 @@ static struct {
 } mmal_omx_video_coding_table[] =
 {
    {MMAL_ENCODING_H264,           OMX_VIDEO_CodingAVC},
+   {MMAL_ENCODING_MVC,            OMX_VIDEO_CodingMVC},
    {MMAL_ENCODING_MP4V,           OMX_VIDEO_CodingMPEG4},
    {MMAL_ENCODING_MP2V,           OMX_VIDEO_CodingMPEG2},
    {MMAL_ENCODING_MP1V,           OMX_VIDEO_CodingMPEG2},
    {MMAL_ENCODING_H263,           OMX_VIDEO_CodingH263},
+   {MMAL_ENCODING_WVC1,           OMX_VIDEO_CodingWMV},
    {MMAL_ENCODING_WMV3,           OMX_VIDEO_CodingWMV},
    {MMAL_ENCODING_WMV2,           OMX_VIDEO_CodingWMV},
    {MMAL_ENCODING_WMV1,           OMX_VIDEO_CodingWMV},
-   {MMAL_ENCODING_WVC1,           OMX_VIDEO_CodingWMV},
    {MMAL_ENCODING_VP6,            OMX_VIDEO_CodingVP6},
    {MMAL_ENCODING_VP7,            OMX_VIDEO_CodingVP7},
    {MMAL_ENCODING_VP8,            OMX_VIDEO_CodingVP8},
    {MMAL_ENCODING_SPARK,          OMX_VIDEO_CodingSorenson},
    {MMAL_ENCODING_THEORA,         OMX_VIDEO_CodingTheora},
+   {MMAL_ENCODING_MJPEG,          OMX_VIDEO_CodingMJPEG},
    {MMAL_ENCODING_UNKNOWN,        OMX_VIDEO_CodingUnused}
 };
 
@@ -602,7 +716,22 @@ static struct {
    {MMAL_ENCODING_RGB24,          OMX_COLOR_Format24bitBGR888},
    {MMAL_ENCODING_ARGB,           OMX_COLOR_Format32bitBGRA8888},
    {MMAL_ENCODING_RGBA,           OMX_COLOR_Format32bitABGR8888},
+   {MMAL_ENCODING_RGB16_SLICE,    OMX_COLOR_Format16bitRGB565},
+   {MMAL_ENCODING_BGR24_SLICE,    OMX_COLOR_Format24bitRGB888},
+   {MMAL_ENCODING_BGRA_SLICE,     OMX_COLOR_Format32bitARGB8888},
+   {MMAL_ENCODING_BGR16_SLICE,    OMX_COLOR_Format16bitBGR565},
+   {MMAL_ENCODING_RGB24_SLICE,    OMX_COLOR_Format24bitBGR888},
+   {MMAL_ENCODING_ARGB_SLICE,     OMX_COLOR_Format32bitBGRA8888},
+   {MMAL_ENCODING_RGBA_SLICE,     OMX_COLOR_Format32bitABGR8888},
    {MMAL_ENCODING_EGL_IMAGE,      OMX_COLOR_FormatBRCMEGL},
+   {MMAL_ENCODING_BAYER_SBGGR8,   OMX_COLOR_FormatRawBayer8bit},
+   {MMAL_ENCODING_BAYER_SBGGR10P, OMX_COLOR_FormatRawBayer10bit},
+   {MMAL_ENCODING_BAYER_SGRBG10P, OMX_COLOR_FormatRawBayer10bit},
+   {MMAL_ENCODING_BAYER_SGBRG10P, OMX_COLOR_FormatRawBayer10bit},
+   {MMAL_ENCODING_BAYER_SRGGB10P, OMX_COLOR_FormatRawBayer10bit},
+   {MMAL_ENCODING_BAYER_SBGGR12P, OMX_COLOR_FormatRawBayer12bit},
+   {MMAL_ENCODING_BAYER_SBGGR16,  OMX_COLOR_FormatRawBayer16bit},
+   {MMAL_ENCODING_BAYER_SBGGR10DPCM8,OMX_COLOR_FormatRawBayer8bitcompressed},
    {MMAL_ENCODING_OPAQUE,         OMX_COLOR_FormatBRCMOpaque},
    {MMAL_ENCODING_UNKNOWN,        OMX_COLOR_FormatUnused}
 };
@@ -623,6 +752,48 @@ OMX_COLOR_FORMATTYPE mmalil_encoding_to_omx_color_format(uint32_t encoding)
    return mmal_omx_colorformat_coding_table[i].coding;
 }
 
+static struct {
+   uint32_t encoding;
+   OMX_COLOR_FORMATTYPE color_format;
+   OMX_BAYERORDERTYPE bayer_order;
+} mmal_omx_bayer_order_coding_table[] =
+{
+   //Colour format required for conversion from OMX to MMAL.
+   //Not used for MMAL encoding to OMX color format.
+   {MMAL_ENCODING_BAYER_SBGGR8, OMX_COLOR_FormatRawBayer8bit, OMX_BayerOrderBGGR},
+   {MMAL_ENCODING_BAYER_SGBRG8, OMX_COLOR_FormatRawBayer8bit, OMX_BayerOrderGBRG},
+   {MMAL_ENCODING_BAYER_SGRBG8, OMX_COLOR_FormatRawBayer8bit, OMX_BayerOrderGRBG},
+   {MMAL_ENCODING_BAYER_SRGGB8, OMX_COLOR_FormatRawBayer8bit, OMX_BayerOrderRGGB},
+
+   {MMAL_ENCODING_BAYER_SBGGR10P, OMX_COLOR_FormatRawBayer10bit, OMX_BayerOrderBGGR},
+   {MMAL_ENCODING_BAYER_SGRBG10P, OMX_COLOR_FormatRawBayer10bit, OMX_BayerOrderGRBG},
+   {MMAL_ENCODING_BAYER_SGBRG10P, OMX_COLOR_FormatRawBayer10bit, OMX_BayerOrderGBRG},
+   {MMAL_ENCODING_BAYER_SRGGB10P, OMX_COLOR_FormatRawBayer10bit, OMX_BayerOrderRGGB},
+
+   {MMAL_ENCODING_BAYER_SBGGR12P, OMX_COLOR_FormatRawBayer12bit, OMX_BayerOrderBGGR},
+   {MMAL_ENCODING_BAYER_SBGGR16,  OMX_COLOR_FormatRawBayer16bit, OMX_BayerOrderBGGR},
+   {MMAL_ENCODING_BAYER_SBGGR10DPCM8,OMX_COLOR_FormatRawBayer8bitcompressed, OMX_BayerOrderBGGR},
+   {MMAL_ENCODING_UNKNOWN,        OMX_COLOR_FormatMax,            OMX_BayerOrderMax}
+};
+
+uint32_t mmalil_omx_bayer_format_order_to_encoding(OMX_BAYERORDERTYPE bayer_order, OMX_COLOR_FORMATTYPE color_format)
+{
+   unsigned int i;
+   for(i = 0; mmal_omx_bayer_order_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
+      if(mmal_omx_bayer_order_coding_table[i].bayer_order == bayer_order &&
+         mmal_omx_bayer_order_coding_table[i].color_format == color_format)
+         break;
+   return mmal_omx_bayer_order_coding_table[i].encoding;
+}
+
+OMX_BAYERORDERTYPE mmalil_encoding_to_omx_bayer_order(uint32_t encoding)
+{
+   unsigned int i;
+   for(i = 0; mmal_omx_bayer_order_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
+      if(mmal_omx_bayer_order_coding_table[i].encoding == encoding) break;
+   return mmal_omx_bayer_order_coding_table[i].bayer_order;
+}
+
 /*****************************************************************************/
 static struct {
    uint32_t mmal;
@@ -805,3 +976,25 @@ OMX_VIDEO_CONTROLRATETYPE mmalil_video_ratecontrol_to_omx(MMAL_VIDEO_RATECONTROL
       if(mmal_omx_video_ratecontrol_table[i].mmal == mmal) break;
    return mmal_omx_video_ratecontrol_table[i].omx;
 }
+
+/*****************************************************************************/
+static struct {
+   MMAL_VIDEO_INTRA_REFRESH_T mmal;
+   OMX_VIDEO_INTRAREFRESHTYPE omx;
+} mmal_omx_video_intrarefresh_table[] =
+{
+   { MMAL_VIDEO_INTRA_REFRESH_CYCLIC,             OMX_VIDEO_IntraRefreshCyclic},
+   { MMAL_VIDEO_INTRA_REFRESH_ADAPTIVE,           OMX_VIDEO_IntraRefreshAdaptive},
+   { MMAL_VIDEO_INTRA_REFRESH_BOTH,               OMX_VIDEO_IntraRefreshBoth},
+   { MMAL_VIDEO_INTRA_REFRESH_KHRONOSEXTENSIONS,  OMX_VIDEO_IntraRefreshKhronosExtensions},
+   { MMAL_VIDEO_INTRA_REFRESH_VENDORSTARTUNUSED,  OMX_VIDEO_IntraRefreshVendorStartUnused},
+   { MMAL_VIDEO_INTRA_REFRESH_DUMMY,              OMX_VIDEO_IntraRefreshMax},
+};
+
+MMAL_VIDEO_INTRA_REFRESH_T mmalil_omx_video_intrarefresh_to_mmal(OMX_VIDEO_INTRAREFRESHTYPE omx)
+{
+   unsigned int i;
+   for(i = 0; mmal_omx_video_intrarefresh_table[i].mmal != MMAL_VIDEO_INTRA_REFRESH_DUMMY; i++)
+      if(mmal_omx_video_intrarefresh_table[i].omx == omx) break;
+   return mmal_omx_video_intrarefresh_table[i].mmal;
+}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.h
index e995eab..b047a28 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.h
@@ -99,6 +99,8 @@ OMX_IMAGE_CODINGTYPE mmalil_encoding_to_omx_image_coding(uint32_t encoding);
 uint32_t mmalil_omx_coding_to_encoding(uint32_t encoding, OMX_PORTDOMAINTYPE domain);
 uint32_t mmalil_omx_color_format_to_encoding(OMX_COLOR_FORMATTYPE coding);
 OMX_COLOR_FORMATTYPE mmalil_encoding_to_omx_color_format(uint32_t encoding);
+uint32_t mmalil_omx_bayer_format_order_to_encoding(OMX_BAYERORDERTYPE bayer_order, OMX_COLOR_FORMATTYPE color_format);
+OMX_BAYERORDERTYPE mmalil_encoding_to_omx_bayer_order(uint32_t encoding);
 uint32_t mmalil_omx_color_space_to_mmal(OMX_COLORSPACETYPE coding);
 OMX_COLORSPACETYPE mmalil_color_space_to_omx(uint32_t coding);
 uint32_t mmalil_omx_video_profile_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding);
@@ -107,6 +109,7 @@ uint32_t mmalil_omx_video_level_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE codi
 OMX_U32 mmalil_video_level_to_omx(uint32_t level);
 MMAL_VIDEO_RATECONTROL_T mmalil_omx_video_ratecontrol_to_mmal(OMX_VIDEO_CONTROLRATETYPE omx);
 OMX_VIDEO_CONTROLRATETYPE mmalil_video_ratecontrol_to_omx(MMAL_VIDEO_RATECONTROL_T mmal);
+MMAL_VIDEO_INTRA_REFRESH_T mmalil_omx_video_intrarefresh_to_mmal(OMX_VIDEO_INTRAREFRESHTYPE omx);
 
 /** Union of all the OMX_VIDEO/AUDIO_PARAM types */
 typedef union OMX_FORMAT_PARAM_TYPE {
@@ -146,6 +149,12 @@ typedef union OMX_FORMAT_PARAM_TYPE {
    OMX_AUDIO_PARAM_EVRCTYPE evrc;
    OMX_AUDIO_PARAM_SMVTYPE smv;
    OMX_AUDIO_PARAM_MIDITYPE midi;
+#ifdef OMX_AUDIO_CodingDDP_Supported
+   OMX_AUDIO_PARAM_DDPTYPE ddp;
+#endif
+#ifdef OMX_AUDIO_CodingDTS_Supported
+   OMX_AUDIO_PARAM_DTSTYPE dts;
+#endif
 
 } OMX_FORMAT_PARAM_TYPE;
 
@@ -158,6 +167,22 @@ typedef union OMX_FORMAT_PARAM_TYPE {
  */
 OMX_INDEXTYPE mmalil_omx_audio_param_index(OMX_AUDIO_CODINGTYPE coding, OMX_U32 *size);
 
+/** Get the audio coding corresponding to a specified OMX_IndexParamAudio index.
+ *
+ * @param index Audio coding type.
+ *
+ * @return Audio coding type.
+ */
+OMX_AUDIO_CODINGTYPE mmalil_omx_audio_param_index_to_coding(OMX_INDEXTYPE index);
+
+/** Setup a default channel mapping based on the number of channels
+ * @param channel_mapping The output channel mapping
+ * @param nchannels Number of channels
+ *
+ * @return MMAL_SUCCESS if we managed to produce a channel mapping
+ */
+MMAL_STATUS_T mmalil_omx_default_channel_mapping(OMX_AUDIO_CHANNELTYPE *channel_mapping, unsigned int nchannels);
+
 /** Convert an OMX_IndexParamAudio into a MMAL elementary stream format.
  *
  * @param format Format structure to update.
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.c
index d68db16..6f45d78 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.c
@@ -61,9 +61,12 @@ MMAL_LIST_T* mmal_list_create(void)
    if (vcos_mutex_create(&private->lock, "mmal-list lock") != VCOS_SUCCESS)
       goto error;
 
+   /* lock to keep coverity happy */
+   vcos_mutex_lock(&private->lock);
    private->list.first = NULL;
    private->list.last = NULL;
    private->list.length = 0;
+   vcos_mutex_unlock(&private->lock);
 
    return &private->list;
 
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.c
index f470210..ec48a5b 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.c
@@ -44,7 +44,6 @@ static MMAL_STATUS_T parse_enum(int *dest, string_pair_t *pairs, size_t n_pairs,
          *dest = pairs[i].value;
          return MMAL_SUCCESS;
       }
-      i++;
    }
    return MMAL_EINVAL;
 }
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.c
index fa10dd6..eb9decb 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.c
@@ -24,7 +24,7 @@ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../mmal.h"
+#include "interface/mmal/mmal.h"
 #include "mmal_encodings.h"
 #include "mmal_util.h"
 #include "mmal_logging.h"
@@ -68,27 +68,81 @@ static struct {
    uint32_t encoding;
    uint32_t pitch_num;
    uint32_t pitch_den;
+   uint32_t alignment;
 } pixel_pitch[] =
 {
-   {MMAL_ENCODING_I420,  1, 1},
-   {MMAL_ENCODING_YV12,  1, 1},
-   {MMAL_ENCODING_I422,  1, 1},
-   {MMAL_ENCODING_NV21,  1, 1},
-   {MMAL_ENCODING_NV12,  1, 1},
-   {MMAL_ENCODING_ARGB,  4, 1},
-   {MMAL_ENCODING_RGBA,  4, 1},
-   {MMAL_ENCODING_RGB32, 4, 1},
-   {MMAL_ENCODING_ABGR,  4, 1},
-   {MMAL_ENCODING_BGRA,  4, 1},
-   {MMAL_ENCODING_BGR32, 4, 1},
-   {MMAL_ENCODING_RGB16, 2, 1},
-   {MMAL_ENCODING_RGB24, 3, 1},
-   {MMAL_ENCODING_BGR16, 2, 1},
-   {MMAL_ENCODING_BGR24, 3, 1},
+   {MMAL_ENCODING_I420,  1, 1, 1},
+   {MMAL_ENCODING_YV12,  1, 1, 1},
+   {MMAL_ENCODING_I422,  1, 1, 1},
+   {MMAL_ENCODING_NV21,  1, 1, 1},
+   {MMAL_ENCODING_NV12,  1, 1, 1},
+   {MMAL_ENCODING_ARGB,  4, 1, 1},
+   {MMAL_ENCODING_RGBA,  4, 1, 1},
+   {MMAL_ENCODING_RGB32, 4, 1, 1},
+   {MMAL_ENCODING_ABGR,  4, 1, 1},
+   {MMAL_ENCODING_BGRA,  4, 1, 1},
+   {MMAL_ENCODING_BGR32, 4, 1, 1},
+   {MMAL_ENCODING_RGB16, 2, 1, 1},
+   {MMAL_ENCODING_RGB24, 3, 1, 1},
+   {MMAL_ENCODING_BGR16, 2, 1, 1},
+   {MMAL_ENCODING_BGR24, 3, 1, 1},
+
+   {MMAL_ENCODING_I420_SLICE,  1, 1, 1},
+   {MMAL_ENCODING_I422_SLICE,  1, 1, 1},
+   {MMAL_ENCODING_ARGB_SLICE,  4, 1, 1},
+   {MMAL_ENCODING_RGBA_SLICE,  4, 1, 1},
+   {MMAL_ENCODING_RGB32_SLICE, 4, 1, 1},
+   {MMAL_ENCODING_ABGR_SLICE,  4, 1, 1},
+   {MMAL_ENCODING_BGRA_SLICE,  4, 1, 1},
+   {MMAL_ENCODING_BGR32_SLICE, 4, 1, 1},
+   {MMAL_ENCODING_RGB16_SLICE, 2, 1, 1},
+   {MMAL_ENCODING_RGB24_SLICE, 3, 1, 1},
+   {MMAL_ENCODING_BGR16_SLICE, 2, 1, 1},
+   {MMAL_ENCODING_BGR24_SLICE, 3, 1, 1},
+
+   {MMAL_ENCODING_YUYV,  2, 1, 1},
+   {MMAL_ENCODING_YVYU,  2, 1, 1},
+   {MMAL_ENCODING_UYVY,  2, 1, 1},
+   {MMAL_ENCODING_VYUY,  2, 1, 1},
+
+   // Bayer formats, the resulting alignment must also be a multiple of 16.
+   // Camplus padded to a multiple of 32, so let's copy that.
+   {MMAL_ENCODING_BAYER_SBGGR8,        1, 1, 32},
+   {MMAL_ENCODING_BAYER_SGBRG8,        1, 1, 32},
+   {MMAL_ENCODING_BAYER_SGRBG8,        1, 1, 32},
+   {MMAL_ENCODING_BAYER_SRGGB8,        1, 1, 32},
+   {MMAL_ENCODING_BAYER_SBGGR10DPCM8,  1, 1, 32},
+   {MMAL_ENCODING_BAYER_SBGGR10P,      10,8, 32},
+   {MMAL_ENCODING_BAYER_SGRBG10P,      10,8, 32},
+   {MMAL_ENCODING_BAYER_SGBRG10P,      10,8, 32},
+   {MMAL_ENCODING_BAYER_SRGGB10P,      10,8, 32},
+   {MMAL_ENCODING_BAYER_SBGGR16,       2, 1, 32},
+
    /* {MMAL_ENCODING_YUVUV128, 1, 1}, That's a special case which must not be included */
    {MMAL_ENCODING_UNKNOWN, 0, 0}
 };
 
+static struct {
+   uint32_t encoding;
+   uint32_t sliced_encoding;
+} slice_equivalents[] =
+{
+   { MMAL_ENCODING_I420,      MMAL_ENCODING_I420_SLICE   },
+   { MMAL_ENCODING_I422,      MMAL_ENCODING_I422_SLICE   },
+   { MMAL_ENCODING_ARGB,      MMAL_ENCODING_ARGB_SLICE   },
+   { MMAL_ENCODING_RGBA,      MMAL_ENCODING_RGBA_SLICE   },
+   { MMAL_ENCODING_RGB32,     MMAL_ENCODING_RGB32_SLICE  },
+   { MMAL_ENCODING_ABGR,      MMAL_ENCODING_ABGR_SLICE   },
+   { MMAL_ENCODING_BGRA,      MMAL_ENCODING_BGRA_SLICE   },
+   { MMAL_ENCODING_BGR32,     MMAL_ENCODING_BGR32_SLICE  },
+   { MMAL_ENCODING_RGB16,     MMAL_ENCODING_RGB16_SLICE  },
+   { MMAL_ENCODING_RGB24,     MMAL_ENCODING_RGB24_SLICE  },
+   { MMAL_ENCODING_BGR16,     MMAL_ENCODING_BGR16_SLICE  },
+   { MMAL_ENCODING_BGR24,     MMAL_ENCODING_BGR24_SLICE  },
+   { MMAL_ENCODING_UNKNOWN,   MMAL_ENCODING_UNKNOWN      },
+};
+
+
 uint32_t mmal_encoding_stride_to_width(uint32_t encoding, uint32_t stride)
 {
    unsigned int i;
@@ -112,7 +166,17 @@ uint32_t mmal_encoding_width_to_stride(uint32_t encoding, uint32_t width)
    if(pixel_pitch[i].encoding == MMAL_ENCODING_UNKNOWN)
       return 0;
 
-   return pixel_pitch[i].pitch_num * width / pixel_pitch[i].pitch_den;
+   return VCOS_ALIGN_UP(pixel_pitch[i].pitch_num * width / pixel_pitch[i].pitch_den, pixel_pitch[i].alignment);
+}
+
+uint32_t mmal_encoding_get_slice_variant(uint32_t encoding)
+{
+   unsigned int i;
+
+   for(i = 0; slice_equivalents[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
+      if(slice_equivalents[i].encoding == encoding) break;
+
+   return slice_equivalents[i].sliced_encoding;
 }
 
 const char* mmal_port_type_to_string(MMAL_PORT_TYPE_T type)
@@ -322,6 +386,7 @@ MMAL_PORT_T *mmal_util_get_port(MMAL_COMPONENT_T *comp, MMAL_PORT_TYPE_T type, u
       return NULL;
    }
    if (index < num)
+      /* coverity[ptr_arith] num is 1 here */
       return list[index];
    else
       return NULL;
@@ -347,3 +412,42 @@ char *mmal_4cc_to_string(char *buf, size_t len, uint32_t fourcc)
    return buf;
 }
 
+#define MAX_ENCODINGS_NUM 20
+typedef struct {
+   MMAL_PARAMETER_HEADER_T header;
+   MMAL_FOURCC_T encodings[MAX_ENCODINGS_NUM];
+} MMAL_SUPPORTED_ENCODINGS_T;
+
+
+int mmal_util_rgb_order_fixed(MMAL_PORT_T *port)
+{
+   int new_fw = 0;
+   //Firmware support of RGB24 vs BGR24 colour ordering from camera
+   //and video splitter components has been corrected as of June 2016.
+   //New firmwares always report MMAL_ENCODING_RGB24 before BGR24, and
+   //that is the format we want.
+   //Old firmware reported BGR24 first, and also returned an error on
+   //the still port on querying MMAL_PARAMETER_SUPPORTED_ENCODINGS.
+
+   MMAL_SUPPORTED_ENCODINGS_T sup_encodings = {{MMAL_PARAMETER_SUPPORTED_ENCODINGS, sizeof(sup_encodings)}, {0}};
+   if (mmal_port_parameter_get(port, &sup_encodings.header) == MMAL_SUCCESS)
+   {
+      int i;
+      int num_encodings = (sup_encodings.header.size - sizeof(sup_encodings.header)) /
+          sizeof(sup_encodings.encodings[0]);
+      for (i=0; i<num_encodings; i++)
+      {
+         if (sup_encodings.encodings[i] == MMAL_ENCODING_BGR24)
+         {
+            //Found BGR24 first - old firmware.
+            break;
+         }
+         if (sup_encodings.encodings[i] == MMAL_ENCODING_RGB24)
+         {
+            //Found RGB24 first - new firmware, so use RGB24.
+            new_fw = 1;
+         }
+      }
+   }
+   return new_fw;
+}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.h
index 0cbb259..556c228 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.h
@@ -28,7 +28,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef MMAL_UTIL_H
 #define MMAL_UTIL_H
 
-#include "../mmal.h"
+#include "interface/mmal/mmal.h"
 
 /** \defgroup MmalUtilities Utility functions
  * The utility functions provide helpers for common functionality that is not part
@@ -66,6 +66,13 @@ uint32_t mmal_encoding_stride_to_width(uint32_t encoding, uint32_t stride);
  */
 uint32_t mmal_encoding_width_to_stride(uint32_t encoding, uint32_t width);
 
+/** Return the 16 line high sliced version of a given pixel encoding
+ *
+ * @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
+ * @return The sliced equivalent, or MMAL_ENCODING_UNKNOWN if not supported.
+ */
+uint32_t mmal_encoding_get_slice_variant(uint32_t encoding);
+
 /** Convert a port type to a string.
  *
  * @param type The MMAL port type.
@@ -164,6 +171,17 @@ MMAL_PORT_T *mmal_util_get_port(MMAL_COMPONENT_T *comp, MMAL_PORT_TYPE_T type, u
 char *mmal_4cc_to_string(char *buf, size_t len, uint32_t fourcc);
 
 
+/** On FW prior to June 2016, camera and video_splitter
+ *  had BGR24 and RGB24 support reversed.
+ *  This is now fixed, and this function will return whether the
+ *  FW has the fix or not.
+ *
+ * @param port   MMAL port to check (on camera or video_splitter)
+ * @return 0 if old firmware, 1 if new.
+ *
+ */
+int mmal_util_rgb_order_fixed(MMAL_PORT_T *port);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.h
index 4b1fae6..9379e03 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.h
@@ -28,7 +28,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef MMAL_UTIL_PARAMS_H
 #define MMAL_UTIL_PARAMS_H
 
-#include "../mmal.h"
+#include "interface/mmal/mmal.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.c
index fd7b054..288b27b 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.c
@@ -148,3 +148,11 @@ void mmal_rational_simplify(MMAL_RATIONAL_T *rational)
    rational->num /= g;
    rational->den /= g;
 }
+
+/** Tests for equality */
+MMAL_BOOL_T mmal_rational_equal(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
+{
+   if (a.num != b.num && a.num * (int64_t)b.num == 0)
+      return MMAL_FALSE;
+   return a.num * (int64_t)b.den == b.num * (int64_t)a.den;
+}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.h
index b2ded7f..f459f51 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.h
@@ -109,6 +109,15 @@ MMAL_RATIONAL_T mmal_rational_from_fixed_16_16(int32_t fixed);
  */
 void mmal_rational_simplify(MMAL_RATIONAL_T *rational);
 
+/** Test 2 rational numbers for equality.
+ *
+ * @param a        First operand
+ * @param b        Second operand
+ *
+ * @return true if equal
+ */
+MMAL_BOOL_T mmal_rational_equal(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/CMakeLists.txt
index 38109a7..d6e80db 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/CMakeLists.txt
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/CMakeLists.txt
@@ -1,9 +1,26 @@
-add_library(mmal_vc_client SHARED mmal_vc_client.c mmal_vc_shm.c mmal_vc_api.c mmal_vc_opaque_alloc.c mmal_vc_msgnames.c mmal_vc_api_drm.c)
-target_link_libraries(mmal_vc_client vchiq_arm vcos)
+add_definitions(-DENABLE_MMAL_VCSM)
+
+add_library(mmal_vc_client ${LIBRARY_TYPE} mmal_vc_client.c mmal_vc_shm.c mmal_vc_api.c mmal_vc_opaque_alloc.c mmal_vc_msgnames.c mmal_vc_api_drm.c)
+#target_link_libraries(mmal_vc_client vchiq_arm vcos)
+
+target_link_libraries(mmal_vc_client vchiq_arm vcos vcsm)
 
 if(BUILD_MMAL_APPS)
 add_executable(mmal_vc_diag mmal_vc_diag.c)
 target_link_libraries(mmal_vc_diag mmal mmal_vc_client debug_sym vcos)
+install(TARGETS mmal_vc_diag RUNTIME DESTINATION bin)
 endif(BUILD_MMAL_APPS)
 
+include_directories ( ../../../host_applications/linux/libs/sm )
+
 install(TARGETS mmal_vc_client DESTINATION lib)
+install(FILES
+   mmal_vc_api.h
+   mmal_vc_api_drm.h
+   mmal_vc_client_priv.h
+   mmal_vc_msgnames.h
+   mmal_vc_msgs.h
+   mmal_vc_opaque_alloc.h
+   mmal_vc_shm.h
+   DESTINATION include/interface/mmal/vc
+)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.c
index bad1721..31502a0 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.c
@@ -67,6 +67,7 @@ typedef struct MMAL_PORT_MODULE_T
 
    MMAL_BOOL_T is_zero_copy;
    MMAL_BOOL_T zero_copy_workaround;
+   uint32_t opaque_allocs;
 
    MMAL_BOOL_T sent_data_on_port;
 
@@ -511,6 +512,12 @@ static void mmal_vc_do_callback(MMAL_COMPONENT_T *component)
    mmal_port_buffer_header_callback(port, buffer);
 }
 
+static void mmal_vc_do_callback_loop(MMAL_COMPONENT_T *component)
+{
+   while (mmal_queue_length(component->priv->module->callback_queue))
+      mmal_vc_do_callback(component);
+}
+
 /** Called back from VCHI(Q) event handler when buffers come back from the copro.
  *
  * The message points to the message sent by videocore, and which should have
@@ -615,7 +622,8 @@ static MMAL_STATUS_T mmal_vc_port_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *
    length = buffer->length;
 
    if (length <= MMAL_VC_SHORT_DATA && !port->priv->module->is_zero_copy &&
-       port->format->encoding == MMAL_ENCODING_OPAQUE)
+       (port->format->encoding == MMAL_ENCODING_OPAQUE ||
+        port->type == MMAL_PORT_TYPE_CLOCK))
    {
       memcpy(msg->short_data, buffer->data + buffer->offset, buffer->length);
       msg->payload_in_message = length;
@@ -673,6 +681,10 @@ static MMAL_STATUS_T mmal_vc_port_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *
       // they need to use the more cumbersome fake-bulk-transfer mechanism
       // to guarantee correct ordering.
       port->priv->module->sent_data_on_port = MMAL_TRUE;
+
+      // Data will be received at the start of the destination buffer, so fixup
+      // the offset in the destination buffer header.
+      msg->buffer_header.offset = 0;
    }
 
    status = mmal_vc_send_message(mmal_vc_get_client(), &msg->header, sizeof(*msg),
@@ -709,7 +721,7 @@ static MMAL_STATUS_T mmal_vc_component_disable(MMAL_COMPONENT_T *component)
       status = reply.status;
    }
 
-   if (status != MMAL_SUCCESS)
+   if (status != MMAL_SUCCESS && status != MMAL_ENOSYS)
    {
       LOG_ERROR("failed to disable component - reason %d", status);
       goto fail;
@@ -740,7 +752,7 @@ static MMAL_STATUS_T mmal_vc_component_enable(MMAL_COMPONENT_T *component)
       status = reply.status;
    }
 
-   if (status != MMAL_SUCCESS)
+   if (status != MMAL_SUCCESS && status != MMAL_ENOSYS)
    {
       LOG_ERROR("failed to enable component: %s", mmal_status_to_string(status));
       return status;
@@ -782,6 +794,8 @@ static MMAL_STATUS_T mmal_vc_component_destroy(MMAL_COMPONENT_T *component)
    if(component->clock_num)
       mmal_ports_free(component->clock, component->clock_num);
 
+   mmal_queue_destroy(component->priv->module->callback_queue);
+
    vcos_free(component->priv->module);
    component->priv->module = NULL;
 
@@ -814,6 +828,27 @@ MMAL_STATUS_T mmal_vc_consume_mem(size_t size, uint32_t *handle)
    return status;
 }
 
+MMAL_STATUS_T mmal_vc_compact(MMAL_VC_COMPACT_MODE_T mode, uint32_t *duration)
+{
+   MMAL_STATUS_T status;
+   mmal_worker_compact req;
+   mmal_worker_compact reply;
+   size_t len = sizeof(reply);
+
+   req.mode = (uint32_t)mode;
+   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
+                                     &req.header, sizeof(req),
+                                     MMAL_WORKER_COMPACT,
+                                     &reply, &len, MMAL_FALSE);
+   if (status == MMAL_SUCCESS)
+   {
+      vcos_assert(len == sizeof(reply));
+      status = reply.status;
+      *duration = reply.duration;
+   }
+   return status;
+}
+
 MMAL_STATUS_T mmal_vc_lmk(uint32_t alloc_size)
 {
    MMAL_STATUS_T status;
@@ -1107,8 +1142,8 @@ static MMAL_STATUS_T mmal_vc_port_parameter_set(MMAL_PORT_T *port, const MMAL_PA
    }
    if (status != MMAL_SUCCESS)
    {
-      LOG_ERROR("failed to set port parameter %u:%u:%s", msg.component_handle, msg.port_handle,
-                mmal_status_to_string(status));
+      LOG_WARN("failed to set port parameter %u:%u %u:%u %s", msg.component_handle, msg.port_handle,
+            param->id, param->size, mmal_status_to_string(status));
       return status;
    }
 
@@ -1132,20 +1167,22 @@ static MMAL_STATUS_T mmal_vc_port_parameter_get(MMAL_PORT_T *port, MMAL_PARAMETE
    MMAL_PORT_MODULE_T *module = port->priv->module;
    MMAL_STATUS_T status;
    mmal_worker_port_param_get msg;
+   size_t msglen = MMAL_OFFSET(mmal_worker_port_param_get, param) + param->size;
    mmal_worker_port_param_get_reply reply;
    size_t replylen = MMAL_OFFSET(mmal_worker_port_param_get_reply, param) + param->size;
 
    if(param->size > MMAL_WORKER_PORT_PARAMETER_GET_MAX)
    {
-      LOG_ERROR("parameter too large (%u > %u)", param->size, MMAL_WORKER_PORT_PARAMETER_GET_MAX);
+      LOG_ERROR("parameter too large (%u > %u) id %u", param->size,
+            MMAL_WORKER_PORT_PARAMETER_GET_MAX, param->id);
       return MMAL_ENOMEM;
    }
 
    msg.component_handle = module->component_handle;
    msg.port_handle = module->port_handle;
-   msg.param = *param;
+   memcpy(&msg.param, param, param->size);
 
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
+   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, msglen,
                                      MMAL_WORKER_PORT_PARAMETER_GET, &reply, &replylen, MMAL_FALSE);
    if (status == MMAL_SUCCESS)
    {
@@ -1168,7 +1205,8 @@ static MMAL_STATUS_T mmal_vc_port_parameter_get(MMAL_PORT_T *port, MMAL_PARAMETE
 
    if (status != MMAL_SUCCESS && status != MMAL_ENOSPC)
    {
-      LOG_ERROR("failed to get port parameter %u:%u", msg.component_handle, msg.port_handle);
+      LOG_WARN("failed to get port parameter %u:%u %u:%u %s", msg.component_handle, msg.port_handle,
+            param->id, param->size, mmal_status_to_string(status));
       return status;
    }
    
@@ -1192,7 +1230,6 @@ static uint8_t *mmal_vc_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_s
    MMAL_PORT_MODULE_T *module = port->priv->module;
    MMAL_BOOL_T can_deref = MMAL_TRUE;
    char buf[5];
-   MMAL_PARAM_UNUSED(module);
    void *ret;
    (void)buf;
 
@@ -1214,6 +1251,7 @@ static uint8_t *mmal_vc_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_s
                    port->name, payload_size);
          return NULL;
       }
+      module->opaque_allocs++;
    }
 
    else if (module->is_zero_copy)
@@ -1250,10 +1288,11 @@ static uint8_t *mmal_vc_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_s
 
 static void mmal_vc_port_payload_free(MMAL_PORT_T *port, uint8_t *payload)
 {
-   MMAL_PARAM_UNUSED(port);
+   MMAL_PORT_MODULE_T *module = port->priv->module;
 
-   if (port->format->encoding == MMAL_ENCODING_OPAQUE)
+   if (module->opaque_allocs)
    {
+      module->opaque_allocs--;
       mmal_vc_opaque_release((MMAL_OPAQUE_IMAGE_HANDLE_T)payload);
       return;
    }
@@ -1354,20 +1393,32 @@ static MMAL_STATUS_T mmal_vc_component_create(const char *name, MMAL_COMPONENT_T
                                         sizeof(MMAL_PORT_MODULE_T));
    if (!component->control)
       goto fail;
-   component->input = mmal_ports_alloc(component, reply.input_num, MMAL_PORT_TYPE_INPUT,
-                                       sizeof(MMAL_PORT_MODULE_T));
-   if (!component->input)
-      goto fail;
+
+   if (reply.input_num)
+   {
+      component->input = mmal_ports_alloc(component, reply.input_num, MMAL_PORT_TYPE_INPUT,
+                                          sizeof(MMAL_PORT_MODULE_T));
+      if (!component->input)
+         goto fail;
+   }
    component->input_num = reply.input_num;
-   component->output = mmal_ports_alloc(component, reply.output_num, MMAL_PORT_TYPE_OUTPUT,
-                                        sizeof(MMAL_PORT_MODULE_T));
-   if (!component->output)
-      goto fail;
+
+   if (reply.output_num)
+   {
+      component->output = mmal_ports_alloc(component, reply.output_num, MMAL_PORT_TYPE_OUTPUT,
+                                           sizeof(MMAL_PORT_MODULE_T));
+      if (!component->output)
+         goto fail;
+   }
    component->output_num = reply.output_num;
-   component->clock = mmal_ports_alloc(component, reply.clock_num, MMAL_PORT_TYPE_CLOCK,
-                                        sizeof(MMAL_PORT_MODULE_T));
-   if (!component->clock)
-      goto fail;
+
+   if (reply.clock_num)
+   {
+      component->clock = mmal_ports_alloc(component, reply.clock_num, MMAL_PORT_TYPE_CLOCK,
+                                           sizeof(MMAL_PORT_MODULE_T));
+      if (!component->clock)
+         goto fail;
+   }
    component->clock_num = reply.clock_num;
 
    /* We want to do the buffer callbacks to the client into a separate thread.
@@ -1375,7 +1426,7 @@ static MMAL_STATUS_T mmal_vc_component_create(const char *name, MMAL_COMPONENT_T
    module->callback_queue = mmal_queue_create();
    if (!module->callback_queue)
       goto fail;
-   status = mmal_component_action_register(component, mmal_vc_do_callback);
+   status = mmal_component_action_register(component, mmal_vc_do_callback_loop);
    if (status != MMAL_SUCCESS)
       goto fail;
 
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.h
index c80fb10..cf9dd27 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.h
@@ -145,7 +145,12 @@ typedef enum
    MMAL_STATS_INVALID = 0x7fffffff
 } MMAL_STATS_RESULT_T;
 
+/* If opening dev_vchiq outside mmal/vchiq this is the file path and mode */
+#define MMAL_DEV_VCHIQ_PATH "/dev/vchiq"
+#define MMAL_DEV_VCHIQ_MODE O_RDWR
+
 MMAL_STATUS_T mmal_vc_init(void);
+MMAL_STATUS_T mmal_vc_init_fd(int dev_vchiq_fd);
 void mmal_vc_deinit(void);
 
 MMAL_STATUS_T mmal_vc_use(void);
@@ -208,6 +213,21 @@ MMAL_STATUS_T mmal_vc_host_log(const char *msg);
  */
 MMAL_STATUS_T mmal_vc_consume_mem(size_t size, uint32_t *handle);
 
+typedef enum
+{
+   MMAL_VC_COMPACT_NONE       = 0,
+   MMAL_VC_COMPACT_NORMAL     = 1,
+   MMAL_VC_COMPACT_DISCARD    = 2,
+   MMAL_VC_COMPACT_AGGRESSIVE = 4,
+   MMAL_VC_COMPACT_SHUFFLE    = 0x80,
+   MMAL_VC_COMPACT_ALL        = MMAL_VC_COMPACT_NORMAL | MMAL_VC_COMPACT_DISCARD | MMAL_VC_COMPACT_AGGRESSIVE,
+} MMAL_VC_COMPACT_MODE_T;
+
+/** Trigger relocatable heap compaction.
+ * @internal
+ */
+MMAL_STATUS_T mmal_vc_compact(MMAL_VC_COMPACT_MODE_T mode, uint32_t *duration);
+
 /** Trigger LMK action from VC, for diagnostics.
  * @internal
  */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client.c
index 4309256..db64dc6 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client.c
@@ -96,24 +96,24 @@ static void init_once(void)
   */
 static MMAL_STATUS_T create_waitpool(MMAL_WAITPOOL_T *waitpool)
 {
-   MMAL_STATUS_T status;
+   VCOS_STATUS_T status;
    int i;
 
    status = vcos_semaphore_create(&waitpool->sem, VCOS_FUNCTION,
                                   MAX_WAITERS);
-   if (status != MMAL_SUCCESS)
-      return status;
+   if (status != VCOS_SUCCESS)
+      return status==VCOS_SUCCESS ? MMAL_SUCCESS : MMAL_ENOSPC;
 
    for (i=0; i<MAX_WAITERS; i++)
    {
       waitpool->waiters[i].inuse = 0;
       status = vcos_semaphore_create(&waitpool->waiters[i].sem,
                                      "mmal waiter", 0);
-      if (status != MMAL_SUCCESS)
+      if (status != VCOS_SUCCESS)
          break;
    }
 
-   if (status != MMAL_SUCCESS)
+   if (status != VCOS_SUCCESS)
    {
       /* clean up */
       i--;
@@ -124,7 +124,7 @@ static MMAL_STATUS_T create_waitpool(MMAL_WAITPOOL_T *waitpool)
       }
       vcos_semaphore_delete(&waitpool->sem);
    }
-   return status;
+   return status==VCOS_SUCCESS ? MMAL_SUCCESS : MMAL_ENOSPC;
 }
 
 static void destroy_waitpool(MMAL_WAITPOOL_T *waitpool)
@@ -589,6 +589,7 @@ MMAL_STATUS_T mmal_vc_sendwait_message(struct MMAL_CLIENT_T *client,
     * FIXME: we could do with a timeout here. Need to be careful to cancel
     * the semaphore on a timeout.
     */
+   /* coverity[lock] This semaphore isn't being used as a mutex */
    vcos_semaphore_wait(&waiter->sem);
 
    mmal_vc_release_internal(client);
@@ -692,7 +693,7 @@ MMAL_STATUS_T mmal_vc_release(void)
    return status;
 }
 
-MMAL_STATUS_T mmal_vc_init(void)
+MMAL_STATUS_T mmal_vc_init_fd(int dev_vchiq_fd)
 {
    VCHIQ_SERVICE_PARAMS_T vchiq_params;
    MMAL_BOOL_T vchiq_initialised = 0, waitpool_initialised = 0;
@@ -716,7 +717,7 @@ MMAL_STATUS_T mmal_vc_init(void)
    vcos_log_register("mmalipc", VCOS_LOG_CATEGORY);
 
    /* Initialise a VCHIQ instance */
-   vchiq_status = vchiq_initialise(&mmal_vchiq_instance);
+   vchiq_status = vchiq_initialise_fd(&mmal_vchiq_instance, dev_vchiq_fd);
    if (vchiq_status != VCHIQ_SUCCESS)
    {
       LOG_ERROR("failed to initialise vchiq");
@@ -791,6 +792,11 @@ MMAL_STATUS_T mmal_vc_init(void)
    return status;
 }
 
+MMAL_STATUS_T mmal_vc_init(void)
+{
+   return mmal_vc_init_fd(-1);
+}
+
 void mmal_vc_deinit(void)
 {
    int count;
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.c
index ba53d45..052b392 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.c
@@ -63,6 +63,7 @@ const char *mmal_msgname(uint32_t id)
       MSGNAME(BUFFER_FROM_HOST_ZEROLEN),
       MSGNAME(PORT_FLUSH),
       MSGNAME(HOST_LOG),
+      MSGNAME(COMPACT),
       { 0, NULL },
    };
    vcos_static_assert(sizeof(msgnames)/sizeof(msgnames[0]) == MMAL_WORKER_MSG_LAST);
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h
index ef21d81..343922b 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h
@@ -39,8 +39,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MMAL_CONTROL_FOURCC() VCHIQ_MAKE_FOURCC('m','m','a','l')
 
-/* Major version indicates binary backwards compatiblity */
-#define WORKER_VER_MAJOR   15
+/* Major version indicates binary backwards compatibility */
+#define WORKER_VER_MAJOR   16
 #define WORKER_VER_MINIMUM 10
 /* Minor version is not used normally.
  */
@@ -102,6 +102,7 @@ typedef enum {
    MMAL_WORKER_BUFFER_FROM_HOST_ZEROLEN,
    MMAL_WORKER_PORT_FLUSH,
    MMAL_WORKER_HOST_LOG,
+   MMAL_WORKER_COMPACT,
    MMAL_WORKER_MSG_LAST
 } MMAL_WORKER_CMD_T;
 
@@ -262,7 +263,7 @@ vcos_static_assert(sizeof(mmal_worker_drm_get_time_reply) <= MMAL_WORKER_MAX_MSG
 /** List of actions for a port */
 enum MMAL_WORKER_PORT_ACTIONS
 {
-   MMAL_WORKER_PORT_ACTION_UNKNOWN = 0,        /**< Unkown action */
+   MMAL_WORKER_PORT_ACTION_UNKNOWN = 0,        /**< Unknown action */
    MMAL_WORKER_PORT_ACTION_ENABLE,             /**< Enable a port */
    MMAL_WORKER_PORT_ACTION_DISABLE,            /**< Disable a port */
    MMAL_WORKER_PORT_ACTION_FLUSH,              /**< Flush a port */
@@ -321,10 +322,19 @@ typedef struct
    mmal_worker_msg_header header;
    uint32_t component_handle;          /**< Which component */
    uint32_t port_handle;               /**< Which port */
-   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size (no data) */
+   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
+   uint32_t space[MMAL_WORKER_PORT_PARAMETER_SPACE];
 } mmal_worker_port_param_get;
 vcos_static_assert(sizeof(mmal_worker_port_param_get) <= MMAL_WORKER_MAX_MSG_LEN);
 
+typedef struct
+{
+   mmal_worker_msg_header header;
+   uint32_t component_handle;          /**< Which component */
+   uint32_t port_handle;               /**< Which port */
+   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
+} mmal_worker_port_param_get_old;
+
 /** Component port parameter get reply. Doesn't include space for the parameter data.
   */
 typedef struct
@@ -472,6 +482,15 @@ vcos_static_assert(sizeof(mmal_worker_consume_mem) <= MMAL_WORKER_MAX_MSG_LEN);
 typedef struct
 {
    mmal_worker_msg_header header;
+   MMAL_STATUS_T status;
+   uint32_t mode;
+   uint32_t duration;
+} mmal_worker_compact;
+vcos_static_assert(sizeof(mmal_worker_compact) <= MMAL_WORKER_MAX_MSG_LEN);
+
+typedef struct
+{
+   mmal_worker_msg_header header;
    /* Message text to add to the circular buffer */
    char msg[MMAL_WORKER_MAX_MSG_LEN - sizeof(mmal_worker_msg_header)];
 } mmal_worker_host_log;
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.c
index 19222ca..e22a53a 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.c
@@ -209,8 +209,14 @@ uint8_t *mmal_vc_shm_lock(uint8_t *mem, uint32_t workaround)
    MMAL_VC_PAYLOAD_ELEM_T *elem = mmal_vc_payload_list_find_handle(mem);
    MMAL_PARAM_UNUSED(workaround);
 
-   if (elem)
+   if (elem) {
       mem = elem->mem;
+#ifdef ENABLE_MMAL_VCSM
+      void *p = vcsm_lock((unsigned int)elem->handle);
+      if (!p)
+         assert(0);
+#endif /* ENABLE_MMAL_VCSM */
+   }
 
    return mem;
 }
-- 
2.0.1

